<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[晚晴幽草轩]]></title>
  <subtitle><![CDATA[It's only too late if you decide it is. Get busy living. or get busy dying!]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://jeffjade.github.io/"/>
  <updated>2016-01-13T16:22:26.000Z</updated>
  <id>http://jeffjade.github.io/</id>
  
  <author>
    <name><![CDATA[jeffjade]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Win下必备神器之Cmder]]></title>
    <link href="http://jeffjade.github.io/2016/01/13/2016-01-13-windows-software-cmder/"/>
    <id>http://jeffjade.github.io/2016/01/13/2016-01-13-windows-software-cmder/</id>
    <published>2016-01-13T13:11:00.000Z</published>
    <updated>2016-01-13T16:22:26.000Z</updated>
    <content type="html"><![CDATA[<p>诚言，对于开发码字者，Mac和Linux果断要比Windows更贴心;但只要折腾下，Windows下也是有不少利器的。之前就有在<a href="http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/" target="_blank" rel="external">Windows下效率必备软件</a>一文中对此做了下记载；其虽没<code>oh-my-zsh</code>那么逆天的存在，却也甚是好用，至少要比Windows原生Cmd好出了天际。因为<strong>好用</strong>，所以<strong>“必备”</strong>。</p>
<a id="more"></a>
<p><img src="http://7xoosr.com1.z0.glb.clouddn.com/cmder.jpg" alt="Cmder"></p>
<h2 id="安裝_cmder"><strong>安裝 cmder</strong></h2><p><a href="http://cmder.net/" target="_blank" rel="external">Cmder官网</a><code>http://cmder.net/</code>（她把conemu，msysgit和clink打包在一起，让你无需配置就能使用一个真正干净的Linux终端！她甚至还附带了漂亮的monokai配色主题。）;作为一个压缩档的存在, 可即压即用。你甚至可以放到USB就可以虽时带着走，连调整过的设定都会放在这个目录下，不会用到系统机码(Registry)，所以也很适合放在Dropbox / Google Drive / OneDrive共享于多台电脑。</p>
<p>下载的时候，有两个版本，分别是mini与full版；唯一的差别在于有没有内建msysgit工具，这是Git for Windows的标准配备；全安装版 cmder 自带了 msysgit, 压缩包 23M, 除了 git 本身这个命令之外, 里面可以使用大量的 linux 命令；比如 grep, curl(没有 wget)； 像vim, grep, tar, unzip, ssh, ls, bash, perl 对于爱折腾的Coder更是痛点需求。</p>
<p><img src="http://7xoosr.com1.z0.glb.clouddn.com/msysgit-bin.png" alt="cmder强大自带命令"></p>
<h2 id="配置_Cmder"><strong>配置 Cmder</strong></h2><h3 id="启动Cmder"><strong>启动Cmder</strong></h3><p>因为她是即压即用的存在，所以点击<code>Cmder.exe</code>即可运行。很显然这般打开她，不怎么快捷，即便用<code>Listary</code>高效搜索到她，然后点击;我们可以这样做:</p>
<ol>
<li><p>把 <strong>cmder</strong> 加到环境变量<br>可以把<code>Cmder.exe</code>存放的目录添加到系统环境变量；加完之后,<code>Win+r</code>一下输入<code>cmder</code>,即可。</p>
</li>
<li><p><strong>添加 cmder 到右键菜单</strong><br>在某个文件夹中打开终端, 这个是一个(超级)痛点需求, 实际上上一步的把 <strong>cmder</strong> 加到环境变量就是为此服务的, 在管理员权限的终端输入以下语句即可:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cmder<span class="class">.exe</span> /REGISTER ALL</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>打开一个管理员权限终端:</strong><br>输入 Ctrl + t, 或者点击下面控制条的绿色加号, 勾选 Run as administrator<br><img src="http://7xoosr.com1.z0.glb.clouddn.com/cmderRunAdmin.jpg" alt="Run as administrator"><br>这就打开了一个管理员权限的终端, 在里面输入上述语句，就可在每个文件夹右键菜单中点击 <code>Cmder here</code>唤起Cmder，方便快捷。</p>
<p>不用打开文件夹就能打Cmder,并进入该目录;爽。</p>
<ol>
<li>借用Win下逆天神器：<code>AutoHotKey</code>（这个下篇要好好记载下）为Cmder配置自己喜欢的快捷键(个人用<code>Alt+r</code>)：<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">!r:: run, D:<span class="command">\*</span>*<span class="command">\cmder</span>_mini<span class="command">\Cmder</span>.exe</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>个人比较推崇使用<code>AutoHotKey</code>；高效简洁，才是王道。</p>
<h3 id="默认开启设置"><strong>默认开启设置</strong></h3><p>作为强大的存在，必然支持私人定制。输入<code>win + alt + p</code>或者 在底部右击点击 settings, 进入设置页面；可以根据自己的所需进行各种配置(字体，皮肤等等等等)。</p>
<p>目前游走在前端，<code>Gulp</code>已离不开，<code>Cmder+PowerShell</code>这个组合无疑是运行gulp的利器。如下图所示，可以设置<code>PowerShell</code>作为默认开启的选项；也可以更改默认开启是所在目录。<br><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderSeting.jpg" alt="Cmder-Seting"></p>
<h3 id="解决文字重叠问题"><strong>解决文字重叠问题</strong></h3><p>Win + Ait + P 唤出设置界面 &gt; mian &gt; font &gt; monospce,去掉那勾勾即可。</p>
<h3 id="修改命令提示符号·λ·"><strong>修改命令提示符号·λ·</strong></h3><p><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderChange.jpg" alt="Cmder修改命令提示符号"><br>Cmder预设的命列列提示符号是<strong>λ</strong>;如果用着不习惯，可以将这个字元改成Mac / Linux环境下常见的<strong>$</strong>符号，具体操作如下：<br>编辑Cmder安装目录下的vendor\init.bat批处理文件(min版本15行)，把：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@prompt</span> <span class="variable">$E</span>[<span class="number">1</span>;<span class="number">32</span>;<span class="number">40</span>m<span class="variable">$P</span><span class="variable">$S</span>&#123;git&#125;&#123;hg&#125;<span class="variable">$S</span><span class="variable">$_</span><span class="variable">$E</span>[<span class="number">1</span>;<span class="number">30</span>;<span class="number">40</span>m &#123;lamb&#125; <span class="variable">$S</span><span class="variable">$E</span>[0m</span><br></pre></td></tr></table></figure></p>
<p>修改成以下即可：<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@prompt</span> <span class="variable">$E</span>[<span class="number">1</span>;<span class="number">32</span>;<span class="number">40</span>m<span class="variable">$P</span><span class="variable">$S</span>&#123;git&#125;&#123;hg&#125;<span class="variable">$S</span><span class="variable">$_</span><span class="variable">$E</span>[<span class="number">1</span>;<span class="number">30</span>;<span class="number">40</span>m <span class="variable">$$</span> <span class="variable">$S</span><span class="variable">$E</span>[0m</span><br></pre></td></tr></table></figure></p>
<p>这个亲测在<code>cmder.exe</code>可以，但在<code>PowerShell.exe</code>需要另行设置:<br>打开文件config/cmder.lua（prompt.lua也有版本是这个），将第二行中的<strong>λ</strong>修改为Linux下常用的<strong>$</strong>即可；亲测可行(2016-01-13)。</p>
<h2 id="常用功能介绍"><strong>常用功能介绍</strong></h2><p>cmder 功能极为强大，功能也非常多，但从视窗画面上看不太出其强大实力，这里就先说下其「看的见」的功能：<br><img src="http://7xoosr.com1.z0.glb.clouddn.com/CmderFunction.png" alt="Cmder强大功能图示"><br>如上图示编号的部分说明如下：<br>1, Cmder常用快捷键<br>跟一般浏览器页签操作习惯一致:</p>
<blockquote>
<p>可以利用<code>Tab</code>，自动路径补全(爽,赞！)；<br>可以利用<strong>Ctrl+T</strong>建立新页签；<br>利用<strong>Ctrl+W</strong>关闭页签;<br>还可以透过<strong>Ctrl+Tab</strong>切换页签;<br><strong>Alt+F4</strong>：关闭所有页签<br><strong>Alt+Shift+1</strong>：开启cmd.exe<br><strong>Alt+Shift+2</strong>：开启powershell.exe<br><strong>Alt+Shift+3</strong>：开启powershell.exe (系统管理员权限)<br><strong>Ctrl+1</strong>：快速切换到第1个页签<br><strong>Ctrl+n</strong>：快速切换到第n个页签( n值无上限)<br><strong>Alt + enter</strong>： 切换到全屏状态；<br><strong>Ctr+r</strong> 历史命令搜索;<br><strong>End, Home, Ctrl</strong> : Traversing text with as usual on Windows</p>
</blockquote>
<p>2, 可在视窗内搜寻画面上出现过的任意关键字。<br>3, 新增页签按钮，可透过滑鼠新增页签。<br>4, 切换页签按钮，可透过滑鼠切换页签。<br>5, 锁定视窗，让视窗无法再输入。<br>6, 切换视窗是否提供卷轴功能，启动时可查询之前显示过的内容。<br>7, 按下滑鼠左键可开启系统选单，滑鼠右键可开启工具选项视窗。 Win+Alt+P  ：开启工具选项视窗</p>
<h2 id="cmder元件组成"><strong>cmder元件组成</strong></h2><p>cmder其实结合了多套软体，其中包括<a href="https://github.com/msysgit/msysgit" target="_blank" rel="external">msysgit</a>与最重要的<a href="http://conemu.github.io/" target="_blank" rel="external">ConEmu</a>与<a href="http://mridgers.github.io/clink/" target="_blank" rel="external">Clink</a>软体，而ConEmu与Clink这两套软体就是cmder真正的核心元件。</p>
<ul>
<li><strong>msysgit</strong>除了提供Git for Windows 相关工具外，其实还提供了多套Unix/Linux 环境下常用的指令列工具，例如less, ls, tar, unzip, md5sum, grep, sed, … 等多套工具。<br>光是一个grep 就不知道比Windows 内建的findstr 强几百倍了！</li>
<li><strong>ConEmu</strong>也可以是单独一款软件存在，曾经一度迷恋于它，然而其体验并不如<strong>cmder</strong>，便放弃它了。</li>
<li><strong>Clink</strong> 将GNU Readline 函式库整合进原生的Windows 命令提示字元视窗，提供命令列模式下强大的编辑与输入能力，这也是用了cmder 之后会这么像在Linux 环境下使用的感觉。</li>
</ul>
<p>上述功能,目前没怎么用，根据<strong>学以致用</strong>原理，也就还没去了解去折腾。</p>
<h3 id="Chocolatey软件包管理系统"><strong><a href="https://chocolatey.org" target="_blank" rel="external">Chocolatey</a>软件包管理系统</strong></h3><p>在 Linux 下，大家喜欢用 apt-get(mac下用brew) 来安装应用程序，如今在 windows 下，大家可以使用 Chocolatey 来快速下载搭建一个开发环境。<code>Chocolatey</code>的哲学就是完全用命令行来安装应用程序， 它更像一个包管理工具（背后使用 Nuget ）</p>
<p>另外需要说明的是， Chocolatey 只是把官方下载路径封装到了 Chocolatey 中，所以下载源都是其官方路径，所以下载的一定是合法的，但是如果原软件是需要 Licence 注册的话，那么 Chocolatey 下载安装好的软件还是需要你去购买注册。不过 Chocolatey 一般还是会选用免费 Licence 可用的软件。</p>
<p>安装chocolatey , 运行如下命令即可：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@powershell -NoProfile -ExecutionPolicy unrestricted -Command &#34;iex ((new-object net.webclient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&#34; &#38;&#38; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin</span><br></pre></td></tr></table></figure></p>
<p>安装软件命令 <code>choco install softwareName</code>, 短写是 <code>cinst softwareName</code><br>可安装的应用程序，可以参见其 <a href="https://chocolatey.org/packages" target="_blank" rel="external">Package列表</a><br>以下是window下开发常用的开发环境应用:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco install autohotkey.portable    #&#23433;&#35013; AutoHotkey (Portable)&#10;choco install nodejs.install  #&#23433;&#35013; node&#10;choco install git.install     #&#23433;&#35013; git&#10;choco install ruby            #&#23433;&#35013; ruby&#10;choco install python          #&#23433;&#35013; python&#10;choco install jdk8            #&#23433;&#35013; JDK8&#10;choco install googlechrome    #&#23433;&#35013; Chrome&#10;choco install google-chrome-x64 #Google Chrome (64-bit only) &#10;choco install firefox         #&#23433;&#35013; firefox&#10;choco install notepadplusplus.install #&#23433;&#35013; notepad++&#10;choco install Atom                    #&#23433;&#35013; Atom&#10;choco install SublimeText3            #&#23433;&#35013; SublimeText3</span><br></pre></td></tr></table></figure></p>
<h2 id="其他功能"><strong>其他功能</strong></h2><ul>
<li><p>Cmder还增加了<strong>alias</strong>功能;他让你用短短的指令执行一些常见但指令超长又难以记忆的语法;比如 <code>ls</code> <code>cls</code>等等；在其控制台输入<code>alias</code>可以查看。</p>
</li>
<li><p>主控台文字自动放大缩小功能，你只要按<strong>下Ctrl+滑鼠滚轮</strong>就可以办到;果你用支援两点触控的笔电，也可以在触控板上用两指放大的手势调整文字大小。还有：<strong>up</strong>，向上翻历史命令;</p>
</li>
<li><p><strong>Cmder</strong>有极为简单的<strong>复制粘贴</strong>操作。<strong>Ctr+V</strong>直接粘贴;用鼠标选中你想拷贝的内容，自动就复制到剪切板；天神，这悉数的美感;点赞!</p>
</li>
<li><p><strong>自定义aliases</strong>:打开Cmder目录下的config文件夹，里面的aliases文件就是我们可以配置的别名文件，只需将里面ls命令的别名按下列方式修改就可以在ls命令下显示中文。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span>=<span class="keyword">ls</span> --show-<span class="keyword">control</span>-chars --<span class="keyword">color</span>=auto <span class="variable">$*</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当然，别名文件还可以有许多其他配置，如：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">e</span>.=explorer .</span><br><span class="line">gcc=<span class="keyword">cd</span> <span class="keyword">D</span>:\Document\gcc\</span><br><span class="line">gw=<span class="keyword">cd</span> <span class="keyword">D</span>:\Document\GitHub\work</span><br><span class="line"><span class="keyword">gl</span>=git <span class="keyword">log</span> --oneline --all --<span class="keyword">graph</span> --decorate  $*</span><br><span class="line"><span class="keyword">ls</span>=<span class="keyword">ls</span> --show-control-chars --color=auto $*</span><br><span class="line"><span class="keyword">pwd</span>=<span class="keyword">cd</span></span><br><span class="line"><span class="keyword">clear</span>=cls</span><br></pre></td></tr></table></figure></p>
<p>这个在公司电脑上总不成功；问题<code>无效的宏定义。</code>;在写到这里时候，还未查明缘由<strong>【待探究，待更新】</strong>。</p>
<p>Windows的cmd就是一个奇葩的存在…如果你愿意花时间去找，你能找到很多的可以替代它的软件，譬如：<code>Babun</code>, <code>Gow</code> ,<code>Conemu</code> , <code>clink</code>等等，任何一款都比原生Cmd来得快意。环境虽如是，体验却在你。</p>
<p>大概就这样，折腾让生活更美好，不止于编程码字。还是那句话，与君共勉：<br>“<strong>过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。</strong>”——陈素封。</p>
<p>参考文章：<br><a href="http://cmder.net/" target="_blank" rel="external">Cmder官网</a><br><a href="https://phphub.org/topics/67" target="_blank" rel="external">利用 Chocolatey 快速在 Windows 下搭建一个开发环境</a><br><a href="http://blog.miniasp.com/post/2015/09/27/Useful-tool-Cmder.aspx" target="_blank" rel="external">介绍好用工具：Cmder ( 具有Linux 温度的Windows 命令提示字元工具 )</a></p>
<hr>
<p>对您可能有用(/感兴趣)的文章：</p>
<ul>
<li><a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/" target="_blank" rel="external">如何优雅地使用Sublime Text</a></li>
<li><a href="http://www.cnblogs.com/jadeboy/p/4165449.html" target="_blank" rel="external">sublime text 下的Markdown写作</a></li>
<li><a href="http://www.jeffjade.com/2015/07/29/2015-07-29-mac-musthave-software/" target="_blank" rel="external">Mac必备软件渐集之ZSH－终极Shell</a></li>
<li><a href="http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/" target="_blank" rel="external">Vimium~让您的Chrome起飞</a></li>
<li><a href="http://www.jeffjade.com/2015/08/28/2015-08-28-Write-Morkdown/" target="_blank" rel="external">SublimeText下写作利器之MarkdownEditing</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Windows下效率必备软件:Cmder介绍;]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Share" scheme="http://jeffjade.github.io/tags/Share/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你所不知道的setInterval]]></title>
    <link href="http://jeffjade.github.io/2016/01/10/2016-01-10-javaScript-setInterval/"/>
    <id>http://jeffjade.github.io/2016/01/10/2016-01-10-javaScript-setInterval/</id>
    <published>2016-01-10T10:30:00.000Z</published>
    <updated>2016-01-10T16:12:26.000Z</updated>
    <content type="html"><![CDATA[<p>在<a href="http://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/" target="_blank" rel="external">你所不知道的setTimeout</a>记载了下<strong>setTimeout</strong>相关,此篇则整理了下<strong>setInterval</strong>；作为拥有广泛应用场景(定时器，轮播图，动画效果，自动滚动等等)，而又充满各种不确定性的这setInterval，自当先洞悉它，才能很好的驾驭它。</p>
<a id="more"></a>
<p><img src="http://7xoosr.com1.z0.glb.clouddn.com/jiangXin.jpg" alt="你所不知道的setInterval"></p>
<h2 id="1-_setInterval()基础"><strong>1. setInterval()基础</strong></h2><p>setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=<span class="string">"button"</span> onclick=<span class="string">"clearInterval(timer)"</span> value=<span class="string">"stop"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<p>上面代码表示每隔1000毫秒就输出一个2，直到用户点击了停止按钮。</p>
<p>与setTimeout一样，除了前两个参数，setInterval 方法还可以接受更多的参数，它们会传入回调函数，下面是一个例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="built_in">arguments</span>.length;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(f, <span class="number">1000</span>, <span class="string">"Hello World"</span>);</span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>
<p>如果网页不在浏览器的当前窗口（或tab），许多浏览器限制setInteral指定的反复运行的任务最多每秒执行一次。</p>
<p>setInterval指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的事件。因此实际上，两次执行之间的间隔会小于指定的时间。比如，setInterval指定每100ms执行一次，每次执行需要5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  alert(i++);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码每隔2000毫秒，就跳出一个alert对话框。如果用户一直不点击“确定”，整个浏览器就处于“堵塞”状态，后面的执行就一直无法触发，将会累积起来。举例来说，第一次跳出alert对话框后，用户过了6000毫秒才点击“确定”，那么第二次、第三次、第四次执行将累积起来，它们之间不会再有等待间隔。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用setInterval，而是每次执行结束后，使用setTimeout指定下一次执行的具体时间。上面代码用setTimeout，可以改写如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  alert(i++);</span><br><span class="line">  timer = setTimeout(<span class="built_in">arguments</span>.callee, <span class="number">2000</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码可以确保两次执行的间隔是2000毫秒。</p>
<p>根据这种思路，可以自己部署一个函数，实现间隔时间确定的setInterval的效果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">interval</span><span class="params">(func, wait)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> interv = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    func.call(<span class="literal">null</span>);</span><br><span class="line">    setTimeout(interv, wait);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  setTimeout(interv, wait);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interval(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码部署了一个interval函数，用循环调用setTimeout模拟了setInterval。</p>
<p>HTML 5标准规定，setInterval的最短间隔时间是<strong>10毫秒</strong>，也就是说，小于10毫秒的时间间隔会被调整到10毫秒。</p>
<h2 id="2-_setInterval运行机制"><strong>2. setInterval运行机制</strong></h2><p><strong>setInterval</strong>的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。</p>
<p>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。</p>
<p>这一点对于setInterval影响尤其大。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  sleeping(<span class="number">3000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>上面的第一行语句要求每隔1000毫秒，就输出一个2。但是，第二行语句需要3000毫秒才能完成，请问会发生什么结果？</p>
<p>结果就是等到第二行语句运行完成以后，立刻连续输出三个2，然后开始每隔1000毫秒，输出一个2。也就是说，setIntervel具有<strong>累积效应</strong>，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发，这可能或造成性能问题（比如集中发出Ajax请求）。</p>
<p>为了进一步理解JavaScript的单线程模型，请看下面这段伪代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#123; 耗时<span class="number">5</span>ms的某个操作 &#125;</span><br><span class="line">  触发mouseClickEvent事件</span><br><span class="line">  &#123; 耗时<span class="number">5</span>ms的某个操作 &#125;</span><br><span class="line">  setInterval(timerTask,<span class="number">10</span>);</span><br><span class="line">  &#123; 耗时<span class="number">5</span>ms的某个操作 &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMouseClick</span><span class="params">()</span></span>&#123;</span><br><span class="line">  耗时<span class="number">8</span>ms的某个操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timerTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">  耗时<span class="number">2</span>ms的某个操作</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure></p>
<p>请问调用init函数后，这段代码的运行顺序是怎样的？</p>
<blockquote>
<p><strong>0-15ms</strong>：运行init函数。<br><strong>15-23ms</strong>：运行handleMouseClick函数。请注意，这个函数是在5ms时触发的，应该在那个时候就立即运行，但是由于单线程的关系，必须等到init函数完成之后再运行。<br><strong>23-25ms</strong>：运行timerTask函数。这个函数是在10ms时触发的，规定每10ms运行一次，即在20ms、30ms、40ms等时候运行。由于20ms时，JavaScript线程还有任务在运行，因此必须延迟到前面任务完成时再运行。<br><strong>30-32ms</strong>：运行timerTask函数。<br><strong>40-42ms</strong>：运行timerTask函数。</p>
</blockquote>
<p>对于setInterval得使用，个人建议是能不用尽量不用。涉及到必须要的定时器，前文已经叙述可以使用两个setTimeout嵌套组合来实现，并且还能规避掉一些问题得发生。涉及到要用它来制作动画（ jQuery就使用setInterval来写动画，也是导致其慢原因之一），更建议使用<strong>requestAnimationFrame</strong>(RAF)，或者直接采用CSS来写（如果可以的话）。</p>
<p><strong>requestAnimationFrame</strong>比起setTimeout、setInterval的优势主要有两点：</p>
<ol>
<li>requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
<li>在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的的cpu，gpu和内存使用量。</li>
</ol>
<p>参考文章链接：<br><a href="http://javascript.ruanyifeng.com/bom/timer.html#toc2" target="_blank" rel="external">阮一峰-javaScript标准参考教程</a></p>
<hr>
<p>您可能会感兴趣的文章：<br><a href="http://www.jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval/" target="_blank" rel="external">你所不知道的setTimeout</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="http://www.jeffjade.com/2016/01/10/2016-01-10-javacript-setTimeout/">你所不知道的setTimeout</a>记载了下<strong>setTimeout</strong>相关,此篇则整理了下<strong>setInterval</strong>；作为拥有广泛应用场景(定时器，轮播图，动画效果，自动滚动等等)，而又充满各种不确定性的这setInterval，自当先洞悉它，才能很好的驾驭它。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[你所不知道的setTimeout]]></title>
    <link href="http://jeffjade.github.io/2016/01/10/2016-01-10-javacript-setTimeout/"/>
    <id>http://jeffjade.github.io/2016/01/10/2016-01-10-javacript-setTimeout/</id>
    <published>2016-01-10T06:30:00.000Z</published>
    <updated>2016-01-10T17:50:40.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。初始接触它的人都觉得好简单，实时上真的如此么？这里记载下，一路对其使用姿势变迁的历程。</p>
<a id="more"></a>
<p><img src="http://7xoosr.com1.z0.glb.clouddn.com/jiangXin1.jpg" alt="你所不知道的setTimeout"></p>
<h2 id="1,_setTimeout()基础"><strong>1, setTimeout()基础</strong></h2><p>setTimeout函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerId = setTimeout(func|code, delay)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout函数接受两个参数，第一个参数func|code是将要推迟执行的函数名或者一段代码，第二个参数delay是推迟执行的毫秒数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">setTimeout(<span class="string">'console.log(2)'</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码的输出结果就是1，3，2，因为setTimeout指定第二行语句推迟1000毫秒再执行(如果这在Sublime下运用插件以nodejs环境来执行，许解释器不同，会报错)。</p>
<p>需要注意的是，推迟执行的代码必须以字符串的形式，放入setTimeout，因为引擎内部使用eval函数，将字符串转为代码。如果<strong>推迟执行的是函数</strong>，则可以直接将函数名，放入setTimeout。一方面eval函数有安全顾虑，另一方面为了便于JavaScript引擎优化代码，setTimeout方法一般总是采用函数名的形式，就像下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(func,<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;<span class="built_in">console</span>.log(<span class="number">2</span>)&#125;,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="setTimeout传参数"><strong>setTimeout传参数</strong></h3><p>除了前两个参数，setTimeout还允许添加更多的参数。它们将被传入推迟执行的函数（回调函数）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">(a,b)</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a+b);</span><br><span class="line">&#125;,<span class="number">1000</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，setTimeout共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p>
<p>IE 9.0及以下版本，只允许setTimeout有两个参数，不支持更多的参数;可以在匿名函数中，让回调函数带参数运行，再把匿名函数输入setTimeout；例如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  myFunc(<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然也可以使用<strong>bind</strong>或<strong>apply</strong>方法来解决。</p>
<p>例如使用bind方法，把多余的参数绑定在回调函数上面，生成一个新的函数输入setTimeout。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span><span class="params">(arg1)</span></span>&#123;&#125;.bind(<span class="literal">undefined</span>, <span class="number">10</span>), <span class="number">1000</span> );</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，bind方法第一个参数是undefined，表示将原函数的this绑定全局作用域，第二个参数是要传入原函数的参数。它运行后会返回一个新函数，该函数不带参数。</p>
<h3 id="setTimeout注意点"><strong>setTimeout注意点</strong></h3><p><strong>setTimeout()中回调函数中的this</strong><br>如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的this关键字将指向全局环境，而不是定义时所在的那个对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  x: <span class="number">2</span>,</span><br><span class="line">  y: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">setTimeout(o.y,<span class="number">1000</span>);<span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码输出的是1，而不是2，这表示o.y的this所指向的已经不是o，而是全局环境了。</p>
<p>再看一个不容易发现错误的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span><span class="params">(login)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.login = login;</span><br><span class="line">  <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.login);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(<span class="string">'John'</span>);</span><br><span class="line">setTimeout(user.sayHi, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码只会显示undefined，因为等到user.sayHi执行时，它是在<strong>全局对象中执行</strong>，所以this.login取不到值。</p>
<p>为了防止出现这个问题，一种解决方法是将user.sayHi放在匿名函数中执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  user.sayHi();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，sayHi是在user作用域内执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>
<p>另一种解决方法是，使用bind方法，将绑定sayHi绑定在user上面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(user.sayHi.bind(user), <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<p>HTML 5标准规定，setTimeout的最短时间间隔是4毫秒。为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE 9以上的版本，会将时间间隔切换到系统定时器，大约是15.6毫秒。</p>
<p><strong>setTimeout执行回调间隔时间长度</strong><br>如果你在一段代码中发现下面内容:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span> <span class="built_in">Date</span>() - startTime);</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br></pre></td></tr></table></figure></p>
<p>请问最后打印的是多少?其正确答案是，取决于后面同步执行的js需要占用多少时间。<br>即为：MAX(同步执行的时间, 100)；缘何如此，就得看下<strong>setTimeout运行机制</strong>了。</p>
<h2 id="2,_setTimeout运行机制"><strong>2, setTimeout运行机制</strong></h2><p>setTimeout和setInterval的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，setTimeout指定的代码，必须等到本次执行的所有代码都执行完，才会执行。</p>
<p>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout和setInterval都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次Event Loop的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，setTimeout和setInterval指定的任务，一定会按照预定时间执行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(someTask,<span class="number">100</span>);</span><br><span class="line">veryLongTask();</span><br></pre></td></tr></table></figure></p>
<p>上面代码的setTimeout，指定100毫秒以后运行一个任务。但是，如果后面立即运行的任务（当前脚本的同步任务））非常耗时，过了100毫秒还无法结束，那么被推迟运行的someTask就只有等着，等到前面的veryLongTask运行结束，才轮到它执行。</p>
<h2 id="3,_setTimeout(func,0)"><strong>3, setTimeout(func,0)</strong></h2><p>在使用backbone框架写代码的时候，因为些需求因素，新手总会在render时操纵下dom，却发现改变dom元素状态，代码没有问题，界面却没有变更。而使用setTimeout(func,time)却能解决这个问题，即便time=0;探究一番，真相只有一个：</p>
<h3 id="setTimeout(func,0)含义"><strong>setTimeout(func,0)含义</strong></h3><p>运行下面代，func1和func2谁会先执行？很明显func2先执行；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    func1();</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">func2();</span><br></pre></td></tr></table></figure></p>
<p>setTimeout的作用是将代码推迟到指定时间执行，如果指定时间为0，即setTimeout(f,0)，那么会立刻执行吗？</p>
<p>答案是不会。因为<strong>setTimeout运行机制</strong>说过，必须要等到当前脚本的同步任务和“任务队列”中已有的事件，全部处理完以后，才会执行setTimeout指定的任务。也就是说，setTimeout的真正作用是，在“任务队列”的现有事件的后面再添加一个事件，规定在指定时间执行某段代码。setTimeout添加的事件，会在下一次Event Loop执行。</p>
<p>setTimeout(f,0)将第二个参数设为0，作用是让f在现有的任务（脚本的同步任务和“任务队列”中已有的事件）一结束就立刻执行。也就是说，setTimeout(f,0)的作用是，尽可能早地执行指定的任务。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"你好！"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码的含义是，尽可能早地显示“你好！”。</p>
<p>setTimeout(f,0)指定的任务，最早也要到下一次Event Loop才会执行。请看下面的例子。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Timeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a() 开始运行"</span>);</span><br><span class="line">  b(x);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"a() 结束运行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">(y)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b() 开始运行"</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"传入的值为"</span> + y);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"b() 结束运行"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"当前任务开始"</span>);</span><br><span class="line">a(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"当前任务结束"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前任务开始</span></span><br><span class="line"><span class="comment">// a() 开始运行</span></span><br><span class="line"><span class="comment">// b() 开始运行</span></span><br><span class="line"><span class="comment">// 传入的值为42</span></span><br><span class="line"><span class="comment">// b() 结束运行</span></span><br><span class="line"><span class="comment">// a() 结束运行</span></span><br><span class="line"><span class="comment">// 当前任务结束</span></span><br><span class="line"><span class="comment">// Timeout</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码说明，setTimeout(f,0)必须要等到当前脚本的所有同步任务结束后才会执行。</p>
<p>0毫秒实际上达不到的。根据<a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#timers" target="_blank" rel="external">HTML5标准</a>，setTimeOut推迟执行的时间，最少是4毫秒。如果小于这个值，会被自动增加到4。这是为了防止多个<strong>setTimeout(f,0)</strong>语句连续执行，造成性能问题。</p>
<p>另一方面，浏览器内部使用32位带符号的整数，来储存推迟执行的时间。这意味着setTimeout最多只能推迟执行2147483647毫秒（24.8天），超过这个时间会发生溢出，导致回调函数将在当前任务队列结束后立即执行，即等同于setTimeout(f,0)的效果。</p>
<h2 id="4,_setTimeout(f,0)应用"><strong>4, setTimeout(f,0)应用</strong></h2><h3 id="调整事件的发生顺序"><strong>调整事件的发生顺序</strong></h3><p>setTimeout(f,0)有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到setTimeout(f, 0)。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input[type=button]'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">input.onclick = <span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    input.value +=<span class="string">' input'</span>;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.body.onclick = <span class="function"><span class="keyword">function</span> <span class="title">C</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  input.value += <span class="string">' body'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码在点击按钮后，先触发回调函数A，然后触发函数C。在函数A中，setTimeout将函数B推迟到下一轮Loop执行，这样就起到了，先触发父元素的回调函数C的目的了。</p>
<p>用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，keypress事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'input-box'</span>).onkeypress = <span class="function"><span class="keyword">function</span><span class="params">(event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.value = <span class="keyword">this</span>.value.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以this.value取不到最新输入的那个字符。只有用setTimeout改写，上面的代码才能发挥作用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'my-ok'</span>).onkeypress = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    self.value = self.value.toUpperCase();</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码将代码放入setTimeout之中，就能使得它在浏览器接收到文本之后触发;<strong>原来如此：</strong>这也就解释了缘何在使用backbone调用render之时，操纵dom是无效的了，因为当时连dom元素都还没获取到(为何没报错？这牵扯到另一个话题),自然等页面渲染完毕了也没见想要的结果了。</p>
<h3 id="分割耗时任何"><strong>分割耗时任何</strong></h3><p>众所周知javascript是<strong>单线程</strong>的，特点就是容易出现阻塞。如果一段程序处理时间很长，很容易导致整个页面hold住。什么交互都处理不了怎么办？</p>
<blockquote>
<p>简化复杂度？复杂逻辑后端处理？html5的多线程？……</p>
</blockquote>
<p>上面都是ok的做法，但是setTimeout也是处理这种问题的一把好手。setTimeout一个很关键的用法就是分片，如果一段程序过大，我们可以拆分成若干细小的块。由于setTimeout(f,0)实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到setTimeout(f,0)里面执行(分片塞入队列)，这样即使在复杂程序没有处理完时，我们操作页面，也是能得到即时响应的。其实就是将交互插入到了复杂程序中执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0xA00000</span>;i&lt;<span class="number">0xFFFFFF</span>;i++) &#123;</span><br><span class="line">  div.style.backgroundColor = <span class="string">'#'</span>+i.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">var</span> timer;</span><br><span class="line"><span class="keyword">var</span> i=<span class="number">0x100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  timer = setTimeout(func, <span class="number">0</span>);</span><br><span class="line">  div.style.backgroundColor = <span class="string">'#'</span>+i.toString(<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">if</span> (i++ == <span class="number">0xFFFFFF</span>) clearInterval(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer = setTimeout(func, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，而写法二就能就不会，这就是<strong>setTimeout(f,0)</strong>的好处。即：可利用setTimeout实现一种伪多线程的概念。</p>
<p>另一个使用这种技巧的例子是，代码高亮的处理。如果代码块很大，就会分成一个个小块，写成诸如<strong>setTimeout(highlightNext, 50)</strong>的样子，进行分块处理。</p>
<h2 id="5,_clearTimeout()"><strong>5, clearTimeout()</strong></h2><p>setTimeout和setInterval函数，都返回一个表示计数器编号的整数值，将该整数传入clearTimeout和clearInterval函数，就可以取消对应的定时器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> id1 = setTimeout(f,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">var</span> id2 = setInterval(f,<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">clearTimeout(id1);</span><br><span class="line">clearInterval(id2);</span><br></pre></td></tr></table></figure></p>
<p>setTimeout和setInterval返回的整数值是连续的(一定环境下，比如浏览器控制台，或者js执行环境等)，也就是说，第二个setTimeout方法返回的整数值，将比第一个的整数值大1。利用这一点，可以写一个函数，取消当前所有的setTimeout。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> gid = setInterval(clearAllTimeouts, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">clearAllTimeouts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (id !== gid) &#123;</span><br><span class="line">        clearTimeout(id);</span><br><span class="line">      &#125;</span><br><span class="line">      id--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>运行上面代码后，实际上再设置任何setTimeout都无效了。</p>
<p>下面是一个clearTimeout实际应用的例子。有些网站会实时将用户在文本框的输入，通过Ajax方法传回服务器，jQuery的写法如下。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'textarea'</span>).on(<span class="string">'keydown'</span>, ajaxAction);</span><br></pre></td></tr></table></figure></p>
<p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发keydown事件，造成大量的Ajax通信。这是不必要的，而且很可能会发生性能问题。正确的做法应该是，设置一个门槛值，表示两次Ajax通信的最小间隔时间。如果在设定的时间内，发生新的keydown事件，则不触发Ajax通信，并且重新开始计时。如果过了指定时间，没有发生新的keydown事件，将进行Ajax通信将数据发送出去。</p>
<p>这种做法叫做debounce（防抖动）方法，用来返回一个新函数。只有当两次触发之间的时间间隔大于事先设定的值，这个新函数才会运行实际的任务。假定两次Ajax通信的间隔不小于2500毫秒，上面的代码可以改写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'textarea'</span>).on(<span class="string">'keydown'</span>, debounce(ajaxAction, <span class="number">2500</span>))</span><br></pre></td></tr></table></figure></p>
<p>利用setTimeout和clearTimeout，可以实现debounce方法。该方法用于防止某个函数在短时间内被密集调用，具体来说，debounce方法返回一个新版的该函数，这个新版函数调用后，只有在指定时间内没有新的调用，才会执行，否则就重新计时。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span><span class="params">(fn, delay)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span>; <span class="comment">// 声明计时器</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法示例</span></span><br><span class="line"><span class="keyword">var</span> todoChanges = debounce(batchLog, <span class="number">1000</span>);</span><br><span class="line"><span class="built_in">Object</span>.observe(models.todo, todoChanges);</span><br></pre></td></tr></table></figure></p>
<p>现实中，<span style="color:#ed1941">最好不要设置太多个setTimeout和setInterval</span>，它们<strong>耗费CPU</strong>。比较理想的做法是，将要推迟执行的代码都放在一个函数里，然后只对这个函数使用setTimeout或setInterval。</p>
<h2 id="6,_如何使用setTimeout"><strong>6, 如何使用setTimeout</strong></h2><p>对<strong>setTimeout</strong>自然不止于这些，但已足见其强大。那么问题来了，需要在项目中大量使用么？视个人和项目而定吧；如不能熟练掌握，不建议多用。毕竟在某些情景之下，setTimeout作为一个hack的方式而存在的（打乱模块的生命周期，并且在问题出现时很难调试，你懂的），譬如：当一个实例还没有初始化的前，我们就使用这个实例，错误的解决办法是使用实例时加个setTimeout，确保实例使用前已初始化。</p>
<p>但只要足够<strong>熟悉</strong>它，以及使用的场景(包括模块生命周期)，使用它也就无可厚非了。比如underscore中不少方法也是基于这setTimeout方法写的；比如非常强大的<code>_.defer</code>： 延迟调用function直到当前调用栈清空为止，类似使用延时为0的setTimeout方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。 如果传递arguments参数，当函数function执行时， arguments 会作为参数传入。</p>
<p>也比如前文提到的防抖动方法debounce_.debounce(function, wait, [immediate]) ;在underscore中其实现方法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">_.debounce = <span class="function"><span class="keyword">function</span><span class="params">(func, wait, immediate)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> last = _.now() - timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    timestamp = _.now();</span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>参考文章链接：<br><a href="http://javascript.ruanyifeng.com/bom/timer.html" target="_blank" rel="external">阮一峰:浏览器对象-定时器</a><br><a href="http://www.css88.com/archives/5804" target="_blank" rel="external">你所不了解的setTimeout</a></p>
<hr>
<p>您可能感兴趣的文章：<br><a href="http://www.jeffjade.com/2016/01/10/2016-01-10-javaScript-setInterval/" target="_blank" rel="external">你所不知道的setInterval</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。初始接触它的人都觉得好简单，实时上真的如此么？这里记载下，一路对其使用姿势变迁的历程。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[所欢喜过的那些电影(2015下)]]></title>
    <link href="http://jeffjade.github.io/2016/01/01/2016-01-01-movie2015/"/>
    <id>http://jeffjade.github.io/2016/01/01/2016-01-01-movie2015/</id>
    <published>2016-01-01T14:12:00.000Z</published>
    <updated>2016-01-05T12:13:47.000Z</updated>
    <content type="html"><![CDATA[<p>只要把美好的回忆珍藏,走到哪里就都不算流浪。然，回忆可以珍藏可以回味，但不要沉迷；走过缤纷万千的2015，悲伤也好，欢喜也罢，都将一去不返。记忆最是带有趋向性和淡忘性，习惯用文字和照片，将过往的美好珍藏，令老来可以按图文以索骥；也能使当下轻装而前行，开始书写一个全然不同的年份和结局…15年兴趣方面，除却听音乐，就是刷电影；这里整理下15年所欢喜过的那些电影，只为一份回忆以珍藏。</p>
<a id="more"></a>
<h3 id="《老炮儿》"><strong>《老炮儿》</strong></h3><p>欣赏时间：2016-01-03(深圳南山百川国际)[上映时间：2015年12月24日]；晚上(16-01-03)同两个兄弟看完,感恸不已，感慨万千；回来有在微信朋友圈感言道：“干，即便天下熙熙皆为利来，天下攘攘皆为利往，男人，有所谓有所不为！道理义气情谊，咱得讲究。“出格儿”的事儿，该办还得办。永远热泪盈眶，永远感动自己”(理性的思维，也还是如此感性)。</p>
<p>说实在的，这部片儿很不错；整个京腔京调飙的听起来挺舒服。许晴颠覆演绎够味儿，冯导主秀合这影帝之名；张涵予霸气血性如旧，鲜肉们表现也是可圈可点，惊喜连连…。至于那日本军刀，原来如此：这是北京特有的文革时期产物。一个是日本武士刀，一个是55式将校呢大衣，是68年顽主的标配，而那些顽主当年也就上初中左右年纪，如今都是五六十岁的老头儿了，俗称老炮儿(得知于豆瓣)。这片儿，值得看看。</p>
<h3 id="《我的少女时代》"><strong>《我的少女时代》</strong></h3><p>欣赏时间：2016-01-03（VST全聚合）[上映时间：2015年11月19日，导演：陈玉珊]；中午(16-01-03)用餐(薏米红豆粥)为了能充分利用时间，在VST中挑选，本来是选中的是极度烧脑的《蝴蝶效应》，无奈有些卡，才换了这部片子。此片临上映那会儿，其已占领微博微信，怎能不知道呢？只是心理上害怕被虐，就没“敢”去看。方才看了，觉挺好；也幸好“有情人忠诚眷属”了。青春片子，总能勾起对过往岁月的感慨；倾羡，是因为在自己青春的时候，责环境因素也罢，说自我限制也好，反正没有如此来一次放浪形骸，敢爱敢为。<strong>青春里面最怕有遗憾，可是遗憾是最不可能避免的</strong>；却也因为有过遗憾，就越发会懂得珍惜；有时候，遗憾也是一种美，即使多半是凄美。</p>
<blockquote>
<p>很久很久以后我们才知道，当一个女孩说她再也不理你，不是真的讨厌你，而是她很在乎你，非常非常在乎你。</p>
</blockquote>
<p>个人感觉这部片子还是很值得一看的。虽然有些点处理的不理想；比如：不分青红皂白的教导主任，以平时成绩和世俗眼光看待坏学生徐太宇，制造矛盾冲突理由过于轻描淡写，为引发后期燃点痕迹过重。不过燃起来给观影人带来的快感还是挺足的；喜欢借女主之口言出的那句：<strong>只有我们自己知道我是谁，只有我们自己能决定自己的样子。</strong></p>
<h3 id="《巴黎假期》"><strong>《巴黎假期》</strong></h3><p>欣赏时间：2016-01-01（VST全聚合）[上映时间：2015年7月31日]。化身“鸡汤暖男”的古天乐，与“邋遢垃圾妹”郭采洁擦出爱情故事，可谓是谱写了一段“灵魂疗伤恋曲”。影片在现浪漫之都巴黎，有蓝天白云下埃菲尔铁塔，有华灯月下凯旋门；有落叶小径，也有闹市街头…；荧屏领略美景之下，这剧情也算丰满,拨人心弦；古天乐诠释到位，很暖；郭采洁演绎的可人可爱。然，回味起来最多的还是那频出的鸡汤金句，比如：</p>
<blockquote>
<p>背叛伤害不了你，能够伤害你的，是因为你太在乎；分手伤害不了你，能够伤害你的，是回忆。短短一生中，我们的痛苦，来源于爱，我们的幸福，也来源于爱。所以，我们的幸福来源于你的爱<br>痛的不是分手，而是忘不了的过去。伤害你的人不是别人，只有你自己。</p>
</blockquote>
<p><strong>曾经拥抱，不枉此爱。人生不能后悔，但可以拐弯。</strong> 这些句子，这个年纪这个点很是喜欢。</p>
<h3 id="《少年班》"><strong>《少年班》</strong></h3><p>欣赏时间： 2016-01-01（VST全聚合）[导演：肖洋；上映时间：2015年6月19]；影片主要讲述了五位“天才少年”被神秘导师慧眼选中，组成“世界数学大赛”攻关小组，从此早于同龄人开始苦乐交织的大学生涯。“天才不常有，但青春故事人人都有，成长的疼痛无论天才或凡人都逃不过。影片以这种前所未有的视角，破天荒首次解密中国教育史上从未公开触及的特殊天才少年群体，以天才的哀伤透视凡人的青春，引发一片共鸣”。(新浪娱乐评）</p>
<p>个人欣赏起来，有被天才之绝技所倾羡；有被青春无畏无敌所感染；有被暗蔑的国式教育所共鸣；有被人性“好的坏”所感慨着；有笑有泪的影片，有泪有笑的观影体验。冯小刚有说其事“言之有物、有情怀的电影”；忘不掉导演借周知庸（孙红雷饰）说的那段极度煽情醒语：</p>
<blockquote>
<p><strong>当你们来到十字路口的时候，你们一定要倾听内心最勇敢的声音，当命运需要你们去逆风飞翔的时候，就不能随风而去</strong>。</p>
</blockquote>
<h3 id="《唐人街探案》"><strong>《唐人街探案》</strong></h3><p>欣赏时间：2015-12-27（深圳星海名城，点映）［导演：陈思诚；上映时间：2015年12月31日］；朋友一起看电影，吃千味涮；怎么感觉都是一部侦探类佳作。一遍赏完，都大感导演兼编剧陈思诚先生（这里必须加先生后缀），很有才也很用心；无论是侦探主题，洋溢的喜剧元素，成龙式的武打风格，还是时而惊悚定格，都非常令人忍不住叫好；错落有致，相互交融；可谓环环相扣，又丝丝入扣。当然各个可以详加推敲角色的诠释，也是相当到位。一遍赏玩后，也觉有些地方没能搞懂：如“萝莉有没有杀小男孩；杀了？为何？没杀，人哪儿去了？”，比如：“最后抓人时候，那个狙击手是怎么回事？为部电影设铺垫么，怎么没有看到其作为？”比如“出现两次的折纸，是为了阐明什么？”,等等。直到看了<a href="http://movie.douban.com/review/7706133/?source=new_aladdin" target="_blank" rel="external">高能剧透——小萝莉的悲惨故事及关于狙击手的推测</a>一文大开的脑洞，更觉起伏跌宕，峰回路转的“探案”背后，还隐藏着巨大的暗流在涌动；因此，很是期待第二部的诞生以及故事的衍生；陈导，看好你。</p>
<p>忘不掉，小萝莉那诡异一笑；心因之大惊，乍感极恐…。</p>
<h3 id="《寻龙诀》"><strong>《寻龙诀》</strong></h3><p>欣赏时间：2015-12-20（深圳海雅缤纷：IMAX3D)[导演：乌尔善；上映时间：2015年12月18日]；该片由天下霸唱所著盗墓小说《鬼吹灯》的后四部改编而成，主要讲述胡八一、王凯旋与Shirley杨再入草原千年古墓发生的故事。豪华的演员阵容，不过感觉除夏雨让人耳目一新外，其余大咖倒稍逊了些，甚至有失其实力水准。剧情上略显单薄，也无精彩的盗墓机关设计（盗墓口诀＋太极八卦图，是在无视我等之不懂乎？）。但，整个观影体验及之后，我等一众屌丝都直呼过瘾。因其精彩的特效，外加首次观看IMAX3D大片儿，以及所采用的国外冒险电影模式，以及时而迸发的喜剧和紧张效果，完全弥补了其他地方的不足。</p>
<p>除了炫酷的特效以及<strong>摸金校尉，合则生，分则死</strong>（那行动前动作感觉不错），还记得较清的就是陈坤一脸淫笑的那句：<strong>你愿不愿意把我们纯洁的革命友谊，再升华一下</strong>。</p>
<h3 id="《万万没想到》"><strong>《万万没想到》</strong></h3><p>观看时间：2015-12-12(深圳星海名城，点映)[导演：易小星；上映时间：2015年12月18日]；该片儿呢，很认真的看了。也多次被开怀的笑了，笑点低，幸福来的就是这么容易；观影20余天后凭空回忆，只有：慕容白的飘逸灵动的身姿和干脆利落的腿法以及几个零散的神反转而已；喔，还有<strong>韩寒</strong>片子的结尾咀嚼着草料的那个表情，以及赵文瑄那段十分搞笑的颠覆演绎；我竟然忘却了女主的那些浪漫和感动。</p>
<p>此处引一段网上说辞(借他人之酒杯，浇我心知块垒)，个人表示很同意：</p>
<blockquote>
<p>观众对有着堪称经典代表作的导演的期许很大，总以为后续之作能超越前作，那么当续作无法超越前作时，人们的心理落差就产生了。珠玉在前，需要钻石在后，那么口碑才会好；珠玉在前，续作只是另一块珠玉，那么口碑就会降低；而珠玉在前，砂石在后，即便这块砂石能在其他一片砂石中鹤立鸡群，那么口碑也会差到极致。<br>陈凯歌先拍了《霸王别姬》后拍了《道士下山》，所以《道士下山》烂；<br>徐峥先拍了《泰囧》后拍了《港囧》，所以《港囧》烂；<br>陆川先拍了《可可西里》后拍了《九层妖塔》，所以《九层妖塔》烂；<br>郑晓龙先拍了《甄嬛传》后拍了《芈月传》，所以《芈月传》烂；<br>《道士下山》、《港囧》、《九层妖塔》对三位导演而言都是珠玉在前砂石在后，而对《万万没想到》的导演叫兽易小星而言，《万万没想到》属于第二种情况，前后之作皆是珠玉。<br>但是，拿《道士下山》、《港囧》、《九层妖塔》、《芈月传》这些“差评”之作与国产的其他同类型的影视剧相比，质量虽非极品，但也算得上是中上等，落得中下等口碑只是因为导演没有超越从前的自己。</p>
</blockquote>
<p>因为对这片儿本没有什么大期待，也就无太多失望；观影如此，看人生百态也是如此。个人对电影还是抱有比较宽容的态度的；至少让人开心笑笑了，也不去说这是部劣作；但也不归其为佳作。悟空等师兄弟出来貌似没看出其作用，并且还把大圣搞成这般尴尬。慕容白原本可以是一个复杂的多维度人物，但因缺乏对人物内心的深处洞察，所有的情节设计都浮于表面，慕容白成为一个单薄的人物，无法给人留下强劲的灵魂冲击和深度的自我反思，如此等等，处理上难免不为人所诟病。整体上，一堆神反转+密集笑点＋另类表演，难以撑起一部佳作的高度；于此片儿 能说的想说的 也就如此了。</p>
<h3 id="《疯狂的麦克斯4：狂暴之路》"><strong>《疯狂的麦克斯4：狂暴之路》</strong></h3><p>欣赏时间：2015-12-11(VST全聚合)[导演：乔治·米勒]；这部片子是在兄弟强烈推荐看的(凌晨一点多欣赏)；他给了一个特别高的预期：燃到爆；看下来真是燃到爆；如果低预期下看着，不知是怎样的感受。只能引用豆瓣一影评：“简直high爆了，前三十分钟已经让人目瞪口呆好几回了，但这电影基本没有要停下来的意思啊，如果一定要分成五六段的话，每两段之间的文戏只有大约三十秒，然后又开始High。。汤老湿前三分之二都没啥台词已经被帅cry，后面掀翻史上最炫酷公路乐队之后开始有台词了完全让人招架不住嘛！”。</p>
<p>贴下度娘给的剧情介绍，感受下：“世界已崩坏，人性已殆尽，这是个血和火的世界，为了生存所有人都必须残酷的斗争。…..“。在那个所有角色都在疯狂以至于狂暴的世界里，观影如你，岂能安然无恙？当然，后期善恶终有了时；经过磨砺和战斗存活下的心灵很身体也得到救赎…也充盈着满满的感动。这片儿值得一看。</p>
<h3 id="《碟中谍5：神秘国度》"><strong>《碟中谍5：神秘国度》</strong></h3><p>欣赏时间：2015-12-11(VST全聚合)［导演：克里斯托夫·迈考利；中国内地上映时间：2015年9月8日］；该片讲述了伊桑·亨特和他的团队遭遇到与他们同样有技艺高超的一个名为“神秘国度”的组织追杀的故事。如今50余岁的不老男神<strong>汤姆·克鲁斯</strong>，又一力作。不讲从头到尾都充实紧张刺激，不说女主角还多次上演美女救英雄的戏码，不谈其剧情非常连贯且扣人心弦，就阿汤哥那份执着与认真，以及所阐释坚持对朋友的忠心，已经让我大爱不已。因为些原因，没能到影院共刷，多少有些遗憾。</p>
<h3 id="《火星救援》"><strong>《火星救援》</strong></h3><p>欣赏时间：2015-11-29(深圳海岸城)[2015年11月25日大陆上映，导演：雷德利·斯科特]；看过了《末日崩塌》这样的片子后，对这部作品特效什么的没大的欢呼。不过影片最后太空对接，倒惊艳到我了。引用<code>1905网评</code>说法：“《火星救援》以科学做背景，影片中的乐观精神，喜剧元素，使影片更像是一部日常的生活小品，只不过导演将科幻变换了风格，讲一个轻松有趣的故事，虽然风格大变，却同样游刃有余，这独有的喜剧元素，反而成为受欢迎的原因，因为这样会让片子更真实，更接地气，不再是神秘的未知世界，也没有高深的理论与思辨。而是由浅到深，很通俗的为大家科普一些知识”。<strong>马特·达蒙</strong>是整部电影的核心，他把自然的演技和往常的魅力注入这个既可以被称为“怪咖”，又可以称作潇洒的冒险家的角色之中，同时为这个拥有多年丰富经验的宇航员赋予了幽默感以及无可替代的乐观精神，同很多网友一样：表示很喜欢这种逗逼乐观自信的geek。</p>
<p>这部“太空荒野求生记剧”还是蛮值得一看的，至少也感叹下：我擦嘞，知识真的可以改变命运耶；喔，记得带上<code>乐观</code>一起。当然，看到<strong>陈数</strong>等中国航天局人物时，多少有些惊奇，我笑了。</p>
<h3 id="《007幽灵党》"><strong>《007幽灵党》</strong></h3><p>欣赏时间：2015-11-15（深圳星海名城）[导演：萨姆.门德斯;上映时间：15-11-13];这部作为《007》系列第24部电影，该片讲述了因为一条来自过去的加密信息，邦德逐步揭开了一个邪恶组织的神秘面纱。为了保全安全机构的正常运转，邦德的上司M与政治势力展开一番争斗的故事。剧情丰富波折，场面宏大不乏紧张，特效炫酷逼真；虽然有些朋友会看到其不足，但当时同两个兄弟一起看还是相当过瘾的（丹尼尔那深邃蓝眼睛和女主那高冷范儿，实在让人欲罢不能，还有风韵万千的莫妮卡·贝鲁奇，哇哦~；客观上也因为前23部只看过一两部）；当然，后来看完第一时间发文感慨就得：应该带妹子看的，你懂的。</p>
<p>月余过去，回忆起来影响最为深刻的就是：片尾邦德扔掉手枪，迈着小靓步，带着迷人微笑，走向女主那份选择，那份帅气！！</p>
<h3 id="《蚁人》"><strong>《蚁人》</strong></h3><p>欣赏时间：2015-10-18(深圳星海名城);[导演：佩顿·里德；大陆上映时间：2015年10月16日]；《蚁人》是漫威影业出品的一部科幻动作电影，取材自漫威漫画，作为漫威电影宇宙的第十二部电影、同时也是第二阶段的收官作品面世。在看此片儿前夕，无意间看了印度一部早期名作《功夫小蝇》，颇为感动；再看完《蚁人》，满是激动赞叹；当时某种程度讲多少有些影响对那些小动物的认知(太感性了有没有？)；时光流转，这些情愫自然也就渐渐淡了。漫威影业出品电影，也是今年才看了几部；但是已然惊赞他们摧枯拉朽和永不枯竭的创造力。</p>
<h3 id="《夏洛特烦恼》"><strong>《夏洛特烦恼》</strong></h3><p>欣赏时间：2015-10-07[深圳京基百纳]；[上映时间:2015-09-30；导演：闫非 彭大魔]；作为15年国庆档一匹很大支黑马；这年头能让大家笑笑的片儿，买的都不错。但也不能因此就说其是佳作了。看完此片有在微信感慨道：</p>
<ul>
<li>1, 影院所播放广告真的，很有创意嘛，可以逗秋雨了。</li>
<li>2, 看电影之前和之中，还是要少喝点水，以分清是笑N的还是腹水储存的多了。</li>
<li>3, 综合来说是各种段子的揉和体。但，拿捏有度，揉搓妥帖。</li>
<li>4, 此虽又一部落魄中年男人意淫的片子，但，有笑有料，如此也算可以了。</li>
<li>5, 国庆也要过去了，突然好想我女朋友，也不知道她这个假期过得怎么样，出去玩时堵不堵，有没有吃好吃的，住在哪里，多大了，叫什么名。。。</li>
</ul>
<p>之后也有偶尔回看下；毕竟有些段子搞的挺搞笑(虽然不怎么高雅，也有点像很多小品的组合)；但毕竟是屌丝男终极YY之作，搞女神屌高富帅，剽窃他人作品走上人参巅峰，最后浪子回头还有个妈一样的老婆在守候，还只是如宠物一样黏着而已！ 对于这宣扬的价值观，多少是有些批判的。幸好怎么解读还是看观众自己。所以也不一棍子打死，谁让一听到那<code>一剪梅</code>就觉好搞笑呢。</p>
<h3 id="《港囧》"><strong>《港囧》</strong></h3><p>欣赏时间：2015-09-25[深圳星海名城];该影片由徐峥执导，由徐峥、赵薇、包贝尔、杜鹃、葛民辉联合主演。作为看着徐峥作品长大的(春光灿烂猪八戒开始)，也是《人在囧途》的超级粉丝；徐峥本人也是别有才，喜剧效果拿捏更是一流；自然对他的作品无形加了很多分。这部《港囧》，自然也觉不错。电影看完就有在简书写到<a href="http://www.jianshu.com/p/23f82c5dfeb8" target="_blank" rel="external">为《港囧》击节</a>;后期也赘言到：</p>
<blockquote>
<p>电影，一种新的文化传播手段。如书，有的喜欢故事段子，有人偏爱诗文歌赋，部分钟情散文议论。电影，真的搞出艺术级别，如王家卫式的，虽好，却也不是谁人都能看懂也喜欢的，自然受众如此的小。《港囧》虽有失偏颇，却也有其可取赞吧，至少用心去揉了那些元素，至少揉的还行，最起码也令人开怀一笑了，并且所述最终也有所升华。如此，相比于国产其他作品，已属难得。若要已国外好水准对比和要求之，未免有点苛求的味道了，毕竟在国内，限制种种，也是客观因素，不是么？</p>
<p>大象无形，大音希声；如今躁动的年代，俗雅的边届，更非能一言以蔽之的。这也不是轻易能够改变的。倒是我国之媒体，宣扬善恶的媒介，呈现世间百态的视窗，却是百态丑劣丛生的沃土，不想提了～。</p>
</blockquote>
<p>如前所述：珠玉在前，需要钻石在后，那么口碑才会好；珠玉在前，续作只是另一块珠玉，那么口碑就会降低；而珠玉在前，砂石在后，即便这块砂石能在其他一片砂石中鹤立鸡群，那么口碑也会差到极致。所以，好不好的，怎么能够说的清楚？能让大家欢喜笑笑，已然不错。</p>
<h3 id="《西游记之大圣归来》"><strong>《西游记之大圣归来》</strong></h3><p>欣赏时间：2015-07-18(深圳星海名城)；[上映时间：2015年7月10，导演：田晓鹏]；作为国产动画在新时代的最杰出代表者，本片的出现为国人带来了莫大的欣喜与欣慰；也是将“自来水”拉到巅峰神黑马；也是本人今年感慨最深的一部电影作品。看完就有在微信朋友发了这样推荐：</p>
<blockquote>
<p>饶是你青春告罄，<br>纵使你童心泯尽，<br>瑕不掩瑜的《大圣归来》，<br>或酷炫，或温情，或诚意，或认真，或尊严…<br>依然会有些东西燃你气来影院的一个超值之觉。</p>
</blockquote>
<p>之后听着戴荃的《悟空》有写了<a href="http://www.jianshu.com/p/bf4c9a2a123e" target="_blank" rel="external">也说这《大圣归来》</a>；狠狠的表达了对该片的赞赏。这里不多讲了，大圣那“熔岩成甲，烈焰为袍”燃到爆，绝对当看的片子。</p>
<h3 id="《捉妖记》"><strong>《捉妖记》</strong></h3><p>欣赏时间：2015年7月16(深圳星海名城)[上映时间：2015年7月16，导演：许诚毅]；上映第一天同朋友下班后就去刷了，看的时候很是开心，毕竟笑料百出，惊喜连连；白百合，姜武，姚晨，小妖王等贡献很大。但看完，却没什么大的感慨(不想上班年看的《末日崩塌》那般，很久依然沉浸在剧情里不能自拔)；后期这部片子一举打破《泰囧》第一宝座，意料之外；但也在情理之中，毕竟带有喜剧元素的作品，只要还可以票房都不错；况且这部作品技术也好，剧情也罢都属上乘。</p>
<h3 id="《我是路人甲》"><strong>《我是路人甲》</strong></h3><p>欣赏时间：2015-07-05(深圳星海名城)［导演：尔冬升；上映时间：2015年7月3日］;该片由一群在横店“漂”的群众演员主演的电影。他们多数不是科班毕业，只是怀揣着对影视表演的爱好，而一头撞进横店的年轻人。男女主角也都是在人生低谷时候“撞”见尔冬升，尔冬升也是偶然机会发现并开始关注那个被称为“横漂”的群体；于是几经努力才有了这部作品。剧情不错，喜剧元素频出，挺逗；讲励志洒鸡汤，也能撕露一些不好的偏执给予警醒。纵使很多不足，也可谓一部很好的片子，值得一看。</p>
<h3 id="《道士下山》"><strong>《道士下山》</strong></h3><p>欣赏时间：2015-07-04(深圳益田假日广场)；[上映时间：2015-07-03；导演：陈凯歌]；嗯，这部片子不多说；也就那样认真看了，虽然后期想想也觉得有些不妥当;尤其是草地紧紧相拥的郭富城和张震在那里滚草地…;作为影片记忆最深刻的除了林志玲那句“属狗了，吃不够？”，就是范伟那般深情心态下的台词：</p>
<blockquote>
<p>人生七十古来稀 前十年幼小，后十年衰老；中间只有五十年，五十年在分成日夜 还有二十五年，再加上刮风下雨、三灾六病，人这一辈子还能剩下多少好日子。</p>
</blockquote>
<p>备注：《头脑特工队》，《煎饼侠》，《解救吾先生》，《九层妖塔》等是在手机网页版下观看，体验和感悟，不甚大；撇此不记；《烈日灼心》没能在影院观看，几经拼凑才看完(费了老大劲儿)；三大男主演绎的都很好，但犯罪动机及其后种种行为解释颇有点牵强(难道笔者灵魂高度不够？)；电影尺度蛮大，在国产院线片，能触碰这么多禁区，也不容易。很值得看下的电影，不同人不同解读(话说，段奕宏也是“喜欢”邓超的，对吧？😄)。</p>
<p>我们常常对于身边的变化固执的抵抗，<br>物是人非的场景往往能引起大家的感慨与共鸣，<br>也许对于很多人来说，回忆中的事物总是格外的华丽，<br>但我们往往忽略了眼前的华丽，忽视了我们现在能把握的美好，<br>回忆可以珍藏，可以回味但不要沉迷，<br>新的轮年，是时候放下沉重的过去开始新的起点了，<br>毕竟没有人可以回到过去重新来过，<br>但谁都可以从现在开始书写一个全然不同的结局…<br>整理完过忘，更好过如今。Go Go Go。</p>
<p>于2016-01-01～2016-01-04断断续续记载，于深圳。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>只要把美好的回忆珍藏,走到哪里就都不算流浪。然，回忆可以珍藏可以回味，但不要沉迷；走过缤纷万千的2015，悲伤也好，欢喜也罢，都将一去不返。记忆最是带有趋向性和淡忘性，习惯用文字和照片，将过往的美好珍藏，令老来可以按图文以索骥；也能使当下轻装而前行，开始书写一个全然不同的年份和结局…15年兴趣方面，除却听音乐，就是刷电影；这里整理下15年所欢喜过的那些电影，只为一份回忆以珍藏。</p>]]>
    
    </summary>
    
      <category term="Movie" scheme="http://jeffjade.github.io/tags/Movie/"/>
    
      <category term="Movie" scheme="http://jeffjade.github.io/categories/Movie/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[写于2015年末的总结]]></title>
    <link href="http://jeffjade.github.io/2015/12/26/2015-12-26-sum_up-in-the-end-of-year/"/>
    <id>http://jeffjade.github.io/2015/12/26/2015-12-26-sum_up-in-the-end-of-year/</id>
    <published>2015-12-26T06:30:00.000Z</published>
    <updated>2016-01-06T03:51:34.000Z</updated>
    <content type="html"><![CDATA[<p><strong>写作</strong>：是为了光阴流逝使我心安（源自知乎一话题），这一出发点鸣动我心；也是此刻键盘敲击动力源之一；兜兜辗转，2015年好或坏的都将成为历史，几近年关，俗念盘桓，免不了感慨总结一番，也算对新一年展望与期待。</p>
<a id="more"></a>
<p>在唠叨之前分享一段，今年一直游走在口边心里的激励，与君共勉：</p>
<blockquote>
<p>“过一个平凡无趣的人生实在太容易了，你可以不读书，不冒险，不运动，不写作，不外出，不折腾……但是，人生最后悔的事情就是：我本可以。”————陈素封.</p>
</blockquote>
<h2 id="关于经历"><strong>关于经历</strong></h2><p>13年毕业后就南下深圳，于一家互联网公司手游开发，一逗留就到了如今；随岁月流走，经环境迁变，回头看主要龄岁被增加了些，附带的增加了些不太通用的工作经验和衍生出痛苦思考后的想法；人开始一旦有了各式各样想法,烦恼便会随之接踵而至～如果想法的背后没有与之匹配的应对之策；15年初期因为这些想法和那些程序员<strong>固有</strong>原因，造就了“世界那么大，想去看看”的浮躁与冲动。</p>
<p>想必，很多不够成熟的程序员都会有同样的困惑：觉得应当要出去看看了，然而对自己实力又不够自信等缘由，如此就有了即使出去了也仍是如此境遇的顾忌；但继续留下，依旧是整日被重复需求所累，成长缓慢（当然也可以分秒必争，惜时效法，熬夜闭关，但这种不明代价的博取不是谁都可以轻易能够而为之的）；如此，一个恶性循环就此诞生了。年初的自己就被束缚在这种漩涡中不能自制。最终，是在5月底转投于了本公司中一从事Web开发的支持部门麾下；零基础学习Web前端，从一点不知道，到知道一点，到知道不知道；一路多艰，幸好裹挟着喜欢，即便不懂，也还热忱不减，乐此不彼地在渴求着成长；如今尚好，学以致用，反促力学，至少确立了日后一段职业生涯为之奋斗的个方向。</p>
<p>最近喜欢上莎士比亚那句名言：”一个人思虑太多，就会失去做人的乐趣 “。warfalcon有一篇<a href="http://chuansong.me/n/2080036" target="_blank" rel="external">如何保持你的积极性</a>，其中有讲到:<strong>正确还是快乐？</strong>“你更愿意正确，还是快乐？你内心对正确的需要，反而让自己产生了消极的想法，因为你不愿意放过任何有可能发生的问题。保持积极，有时候是对是错并不重要”。岂非如此？世上事，本就难分对错正确与否，何苦要为那虚无苦了那颗心？有时候如果没有非在乎不可的顾忌，那么思考清楚的事儿，就去跟随内心走选择呗；走的通亮了，欣喜吧。走的若不顺，也是一段经历；并且也比于当下见识了更广袤的世界，不是么？</p>
<h2 id="关于博客"><strong>关于博客</strong></h2><p><strong>博客目的</strong>: 谈及这个，率先得说下写作(是为了光阴流逝使我心安);也就其他诸多因素,有一个蛮重要正如胡适在《怎样读书》中阐述的</p>
<blockquote>
<p>我們平時所說的吸收進來的思想，無論是聽來的，或是看來的，不過在腦子裏有壹點好或壞的模糊而又零碎的東西罷了。倘若費壹番工夫，把他芟除的芟除，整理的整理，綜合起來作做成劄記，然後那經過整理和綜合的思想，就永久留在腦中；於是這思想，就屬於自己的了。</p>
</blockquote>
<p>那么为何要亦博客来呈现？关于这个很多前辈大牛早已总结，很久之前在<a href="http://www.jeffjade.com/2015/02/01/2015-02-01-recommended-article/" target="_blank" rel="external">墙裂推荐文章集锦</a>一文关于“写作”部分有过收录。个人也觉得从网络获得过很多问题解决办法的我们，在力所能及之时也当奉献一份自己的力量；而要不误人子弟，对于所述之文也有一份责任，这反过来也会促进对于该事务的认知和理解；如果写文和读文中能和他人有交互，彼此都能获取一份开阔和提升，何乐不为？当然，浮躁的年代，年轻的我们谁还没点虚荣心呢？</p>
<p><strong>博客变迁</strong>: 最早期用的是<code>博客园</code>；14年底有在Github 下以<code>Jekyll</code>搭建一个练手之用；15年入手Mac之后有用<code>Hexo</code>“搭建”（其实是用了<code>@jacman</code>主题，按照自己喜好修修改改了而已）如今这个，并购买域名<code>jeffjade.com</code>;一度迁移到国内<code>gitcafe</code>，虽然免费，服务也好，速度也快，就是不很稳定，后来还是回归github的怀抱；当然前段时间也fork出一份jekyll博客，只为看下其设计，这是题外话了；一路折腾过来，算是对当下个人博客搭建等有了些了解。</p>
<p><strong>博客内容</strong>： 写作这事儿，谁天生都行呢？技术这事儿，岂不也需要磨砺！很多事儿，其实都是从模仿开始的。即便今时今日，写得几点心得，也是颇多参考网络上故有的见解（互联网真好）。目前见识知识还亟待提升，所苟留内容难免只是一个搬运工而已，即便偶尔写的一些<code>游记</code> <code>想法</code> <code>音乐</code>等也不尽我意，但成长只是路上而已；并且在以<strong>用心分享</strong>的虔诚之下，也不至于贻祸他人；往后的日子中会尽量自己原创，除过技术经验心得总结外，<code>写写影评</code> <code>嘀嗒些经验</code> 或者<code>搬运些自我放松大法</code>（这有别于“鸡汤”，在微信里阅尽鸡汤，听过无数道理，依旧过不好一生；我想说，端上“鸡汤”好人儿，请换行“春药”也好～，😂）等；让技术和写作共舞，令专业同兴趣齐飞；倘能如愿，幸甚至哉。</p>
<h2 id="关于工具"><strong>关于工具</strong></h2><p>作为火影迷的话，都知道<strong>多重影分身</strong>对与早期早期鸣人来讲，是其最为薄弱的技能；后来因缘造化有短致长，，很长时间却成为他的主流技能；在14年偶然接触Win下<code>Everything</code>工具(可见笔者那时候见识多么浅薄，其实现在也是)之后，便走上了伪工具控的道路；只因她带给自己很早惊喜，节省很多时间；同时于思维也是一个颇大的转换：<strong>工欲善其事，必先利其器</strong>；除此外，无论编程还是人生享受，也亦如此，生命有限，能够抽象出一些重复之事，交付与可利用的工具，节省出来更多时间，除了享受本身，其实还可以早就更多可能性，何乐不为？</p>
<ul>
<li>3月初有国行入手一台MacBook Pro(关于价格：如果可以还是买港行；近2千大洋的差价可以感受下天朝关税之猛烈么？<strong>土豪请无视</strong>)；有她真好。9个月来没怎么关机，坐下打开，合上就走；虽没怎用她工作，却由她见证了很多欢喜；早先也有感慨道：<a href="http://www.jeffjade.com/2015/07/24/2015-07-24-why-programmer-love-mac/" target="_blank" rel="external">Mac，无愧设备中优雅的情人</a>。公司戴尔即便又加了内存，怎么给自己的感觉还是：<strong>珍爱生命，远离Windows</strong>(当然这很有偏见，高配Window必然有其可取处，只是还没机会拥有而已)。</li>
<li>6月初有一台日本产的<strong>青轴Filco</strong>；只能说处于健康和享受来讲，机械键盘值得拥有，这真不是“装B”的说；关于这个在<a href="http://www.jeffjade.com/2015/06/05/2015-06-05-Share-Filco/" target="_blank" rel="external">码字者的倚天剑</a>有比较详尽的叙述。</li>
<li>7月份有入手两件Ipod Shuffle;读书用Kindle，听歌手机活着Mac，运动时候，一个人行走在路上（这个要注意安全），就得用她，玲珑小巧，却精致够用；重要的是便捷&amp;续航能力，喜之不尽。</li>
<li>9月份公司windows有加了SSD，用起来稍有些；关键是发现并用上了<code>AutohotKey</code> <code>Listary</code> <code>Cmder</code> <code>Clover</code>等软件之后，即便几个软件加起来也不如Mac下的<code>Alfred</code>，但满满的也都是欢喜啊。这在<a href="http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/" target="_blank" rel="external">Windows下效率必备软件</a>和  <a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/" target="_blank" rel="external">追寻高效工作的一路折腾</a> 等文章中有过记载;今年也是将使用SublimeText的经验经验升华了下，并做梳理有载于<a href="http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/" target="_blank" rel="external">如何优雅地使用Sublime Text</a>;</li>
</ul>
<p><strong>工具</strong>，也不能仅限于这些机器，硬件，软件；开发可以是框架，轮子,工具库或是脚本等等；码字可以有一些语言Markdown或是Wiki；更可以是思考事情的一种分析思维，一种处理处理事务技法云云，2015年在这里有所投入，也就有些收获和启发，大概就这样。</p>
<h2 id="关于感慨"><strong>关于感慨</strong></h2><p>人生历程中，让人改变成长于大多人来讲都是情感；只有直击心灵深入，才能唤起最透彻的领悟。今年最多的感触也是在于这情感二字上，谁又能逃得掉？这里不宜多写(会悄悄在<strong>为知</strong>中哭与笑)；金庸先生在《书剑恩仇录》中有话用《尚书》一句，倒是很贴切现在的心境的，贴于此处与君共勉：“<strong>慧极必伤，情深不寿，强极则辱，谦谦君子，温润如玉</strong>”。世间烦恼，几乎无外出于两点：有了<strong>执念</strong>；抑或<strong>执念</strong>不够坚定（写到此处，网易云音乐正播放至～《天龙八部》插曲思君黯然，额，引喜勾伤潺潺，温润咽喉和心窗～）罢了，幸好，世间事，还有时间这块良药不是么？豁达以朗，渐渐而放，一切都还好。</p>
<p>生活不如意事情，十有八九；有了不如意才能品味<strong>如意之事</strong>；职场亦如是,撇此不提。倒是对于求知的路上，热忱有余，却有了这里本不该有的<strong>“见异思迁”</strong>，不能做到专注,很早就认识到这一点，却不能自制，这也是16年特需修正的一个点。前段时间有看到@前端早读课<a href="http://wx.h5.vc/post/translations/2015-12-14" target="_blank" rel="external">2016年你应该学习的语言和框架</a>,知道下“深似海的前端”需要折腾的还很多，但也当冷静对待，适当取舍，逐一而破。另一件亟待修正的是：无休止的不规律作息和缺乏身体锻炼；毕竟朝九晚六的工作之后，又逗留公司做些有的没的，回去已是晚十点左右；一日单调生活，总觉这一日没过够过好，必需些娱乐和兴趣予以调解，不觉间在睡时多半在凌晨一点以后了；这点得从意识和行动中逐步规划和改善。</p>
<p>15年列了些清单，关于<strong>待刷装备</strong>，<strong>待学技艺</strong>，<strong>待旅行之地</strong>等等，完成的情况离满意尚有段距离；而关于<strong>待读书籍</strong>则相去甚远，整年竟没好好读几本好书，大憾事！！电影动漫倒是刷了好些(尤其电影，几乎刷尽今年有名气片子，感触良多)，也追了几部不错电视剧，以及听了很多歌曲；这话题先按下不提。新的一年须在此尚能更好的历程后，重新审视规划List，让16年行走的更为充实开心，新颖有致。零散的写了些有的没的，算是年末对这360多天过往的一个小交代；不忘过去，也为更好的将来；希望16年的自己，不忘初心，不失热忱，趋于稳重，日臻成熟。</p>
<p>大概就这样，明年此时，期待字里行间多一分自信与从容，洒脱和无憾。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>写作</strong>：是为了光阴流逝使我心安（源自知乎一话题），这一出发点鸣动我心；也是此刻键盘敲击动力源之一；兜兜辗转，2015年好或坏的都将成为历史，几近年关，俗念盘桓，免不了感慨总结一番，也算对新一年展望与期待。</p>]]>
    
    </summary>
    
      <category term="Thought" scheme="http://jeffjade.github.io/tags/Thought/"/>
    
      <category term="Thought" scheme="http://jeffjade.github.io/categories/Thought/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[如何优雅地使用Sublime Text]]></title>
    <link href="http://jeffjade.github.io/2015/12/15/2015-04-17-toss-sublime-text/"/>
    <id>http://jeffjade.github.io/2015/12/15/2015-04-17-toss-sublime-text/</id>
    <published>2015-12-15T04:50:00.000Z</published>
    <updated>2016-01-05T11:32:39.000Z</updated>
    <content type="html"><![CDATA[<p>Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。</p>
<a id="more"></a>
<h2 id="如何优雅地使用Sublime_Text之目录："><strong>如何优雅地使用Sublime Text之目录：</strong></h2><ul>
<li><a href="#one">Sublime Text 2和3的对比</a></li>
<li><a href="#two">Sublime Text 3安装插件</a></li>
<li><a href="#three">Sublime Text 3插件推荐</a></li>
<li><a href="#four">定制属于自己的快捷键</a></li>
<li><a href="#five">Sublime不可不知的实用技巧</a></li>
<li><a href="#six">定制属于自己的个性化主题</a></li>
<li><a href="#seven">Sublime锦上添花些许设置</a></li>
<li><a href="#eight">写在一路更来的结语</a></li>
</ul>
<p></p><h2 id="one"><b>Sublime Text 2和3的对比</b></h2><br>相比于2，Sublime Text 3就秒启动一项，就压倒性地胜利了。因此在之后的叙述中都以Sublime Text 3为主角。并且3一直在不断的完善更新，具体的差异可参看<a href="http://www.sublimetext.com/blog/" target="_blank" rel="external">Sublime Blog</a>.简单的说：<p></p>
<blockquote>
<ul>
<li>ST3支持在项目目录里面寻找变量</li>
<li>提供了对标签页更好地支持（更多的命令和快捷键）</li>
<li>加快了程序运行的速度</li>
<li>更新了API，使用Python3.3</li>
</ul>
</blockquote>
<p>强烈推荐朋友们使用3! 唯快不破，不解释。</p>
<p></p><h2 id="two"><b>Sublime Text 3安装插件</b></h2><br>Sublime Text的强大就是她拥有强大的课可扩展性。您可根据自己的需要安装不同的插件；这使得她变的无比强大的同时又不失轻便。<p></p>
<ul>
<li><p><strong>插件安装方式一：直接安装：</strong></p>
<blockquote>
<p>安装Sublime text 3插件很方便，可以直接下载安装包解压缩到Packages目录（菜单-&gt;preferences-&gt;packages）。</p>
</blockquote>
</li>
<li><p><strong>插件安装方式二：使用Package Control组件安装：</strong></p>
<blockquote>
<p>按Ctrl+`调出console（注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音）粘贴以下代码到底部命令行并回车：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request,os; pf = <span class="string">'Package Control.sublime-package'</span>; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), <span class="string">'wb'</span>).write(urllib.request.urlopen( <span class="string">'http://sublime.wbond.net/'</span> + pf.replace(<span class="string">' '</span>,<span class="string">'%20'</span>)).read())</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>重启Sublime Text 3。如果在Perferences-&gt;package settings中看到package control这一项，则安装成功。按下Ctrl+Shift+P调出命令面板输入install 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。</p>
</blockquote>
<p>PS：国内使用SublimeText3，经常可能遇到无法安装可用插件问题，可remove掉<strong>Package Control</strong>重新安装下；如遇到连Package Control也无法安装，则可以在别处拷贝一份关于Package Control的文件－(Package Control.sublime-package)存放于<code>Installed Packages</code>目录之下即可。</p>
<p></p><h2 id="three"><b>Sublime Text 3插件推荐</b></h2><br><strong>无插件，不神器！</strong>根据自己的需要定制属于自己的强大插件集；下面是一些常用的推荐。<br><a href="http://www.jianshu.com/p/5905f927d01b" target="_blank" rel="external">Sublime Text3插件：增强篇</a><br><a href="http://www.open-open.com/news/view/26d731" target="_blank" rel="external">20个强大的SublimeText插件</a><br>作为在移动端旧游之后，又Web端新游的自己，墙裂推荐以下这么几款插件：<p></p>
<p><strong><a href="https://github.com/SublimeText-Markdown/MarkdownEditing" target="_blank" rel="external">MarkDown Editing</a></strong><br>    SublimeText不仅仅是能够查看和编辑 Markdown 文件，但它会视它们为格式很糟糕的纯文本。这个插件通过适当的颜色高亮和其它功能来更好地完成这些任务。关于如何在SublimeText下高效些东西可参见文章：<a href="http://www.cnblogs.com/jadeboy/p/4165449.html" target="_blank" rel="external">sublime text 2(3)下的Markdown写作</a> 抑或是前段时间写下的<a href="http://www.jeffjade.com/2015/08/28/2015-08-28-Write-Morkdown/" target="_blank" rel="external">追寻高效工作的一路折腾㈡</a><br><strong><a href="https://github.com/titoBouzout/SideBarFolders" target="_blank" rel="external">SideBarFolders</a></strong><br>    打开的文件夹都太多了? 来用这个来管理文件夹，世界原来也可以这么美好。<br>    <img src="http://www.jeffjade.com/img/toss/sublimetext-folder.png" alt="SideBarFolders"><br><strong><a href="http://wbond.net/sublime_packages/terminal" target="_blank" rel="external">Sublime Terminal</a></strong><br>    这个插件可以让你在Sublime中直接使用终端打开你的项目文件夹，并支持使用快捷键。<br><strong><a href="http://weslly.github.io/ColorPicker/" target="_blank" rel="external">ColorPicker</a></strong><br>    通常，如果你想使用一个颜色选择器则可能打开 Photoshop 或 GIMP。而在 Sublime Text 中，你可以使用内置的颜色选择器。安装完成后，只要按下Ctrl / Cmd + Shift + C 快捷键。<br><strong><a href="https://github.com/wuub/SublimeREPL" target="_blank" rel="external">SublimeREPL</a></strong><br>    这可能是对程序员很有用的插件。SublimeREPL 允许你在 Sublime Text 中运行各种语言（NodeJS ， Python，Ruby， Scala 和 Haskell 等等）。</p>
<p><strong><a href="https://github.com/SublimeText/CTags" target="_blank" rel="external">Ctags插件</a></strong><br>有童鞋抱怨Sublime Text不能支持函数的跳转（比如像Eclipse那样，按住Control点击该方法或者对象，即可跳转到定义的地方； Alt+←即可回到原处）。其实Sublime Text也可以借助插件实现之（当然，有些情况下:Can not find defination）毕竟这个也是借助正则来匹配完成的。因此这个也就要求代码很规范。这个插件相对来讲会有些麻烦，具体的可以参见:<a href="http://firstleaf.diandian.com/post/2013-03-29/40049695682" target="_blank" rel="external">Sublime Text ctags 的配置</a>.</p>
<p><strong><a href="https://github.com/SublimeLinter" target="_blank" rel="external">SublimeLinter插件</a></strong><br>SublimeLinter 是前端编码利器——<a href="http://www.cnblogs.com/lhb25/archive/2012/12/28/best-tools-for-web-development-b.html" target="_blank" rel="external"><strong>Sublime Text</strong></a> 的一款插件，用于高亮提示用户编写的代码中存在的不规范和错误的写法，支持 JavaScript、CSS、HTML、Java、PHP、Python、Ruby 等十多种开发语言。这篇文章介绍如何在 Windows 中配置 SublimeLinter 进行 JS &amp; CSS 校验。<br>比如写例如像lua这样的弱语言脚本代码，有这个可以规避掉很多不该有的低级错误吧？当然这也需要你SublimeLinter安装完毕之后再安装一个<code>SublimeLinter-lua</code>即可。具体的使用可以参见：<a href="http://www.cnblogs.com/lhb25/archive/2013/05/02/sublimelinter-for-js-css-coding.html" target="_blank" rel="external">借助 SublimeLinter 编写高质量的 JavaScript &amp; CSS 代码</a></p>
<p><strong><a href="https://github.com/titoBouzout/SideBarEnhancements" target="_blank" rel="external">SideBarEnhancements插件</a></strong><br>SideBarEnhancements是一款很实用的右键菜单增强插件；在安装该插件前，在Sublime Text左侧FOLDERS栏中点击右键，只有寥寥几个简单的功能；安装了就相当于给其丰了大胸一般。<br><strong>更强大的是</strong>，该插件还能让我们自定义快捷键呼出某个浏览器以预览页面！这样就不用到项目目录下寻找和拖动到特定浏览器中预览了。<br>安装此插件后，点击菜单栏的<em>preferences-&gt;package setting-&gt;side bar-&gt;Key Building-User</em>，键入以下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[   </span><br><span class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"ctrl+shift+c"</span>], <span class="string">"command"</span>: <span class="string">"copy_path"</span> &#125;,</span><br><span class="line">    //chrome</span><br><span class="line">    &#123; <span class="string">"keys"</span>: [<span class="string">"f2"</span>], <span class="string">"command"</span>: <span class="string">"side_bar_files_open_with"</span>,</span><br><span class="line">            <span class="string">"args"</span>: &#123;</span><br><span class="line">                <span class="string">"paths"</span>: [],</span><br><span class="line">                <span class="string">"application"</span>: <span class="string">"C:\\Users\\jeffj\\AppData\\Local\\Google\\Chrome\\Application\\chrome.exe"</span>,</span><br><span class="line">                <span class="string">"extensions"</span>:<span class="string">".*"</span></span><br><span class="line">            &#125;</span><br><span class="line">     &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>这里设置按Ctrl+Shift+C复制文件路径，按F2即可在Chrome浏览器预览效果(如果需要的话，也可以根据自己的需要为Firefox，Safari，IE，Opera等加上)，当然你也可以自己定义喜欢的快捷键，最后注意代码中的浏览器路径要以自己电脑里的文件路径为准。</p>
<p><strong><a href="https://github.com/victorporof/Sublime-HTMLPrettify" target="_blank" rel="external">HTML-CSS-JS Prettify</a></strong><br>一款集成了格式化（美化）html、css、js三种文件类型的插件，即便html,js写在PHP文件之内。插件依赖于nodejs，因此需要事先安装nodejs，然后才可以正常运行。插件安装完成后，快捷键ctrl+shift+H完成当前文件的美化操作。插件对html、css文件的美化不是非常满意，但还可以，后面将说明如何修改css美化脚本。本人用起来超级爽的，鉴于篇幅，就不赘述，可以参见<a href="http://frontenddev.org/article/sublime-does-text-three-plug-ins-html-and-css-js-prettify.html" target="_blank" rel="external">这篇</a>介绍。</p>
<p><strong><a href="https://github.com/csscomb/CSScomb-for-Sublime" target="_blank" rel="external">CSScomb CSS属性排序</a>:</strong><br>有时候看看自己写的CSS文件，会不会觉得属性很乱查找不易维护难？CSScomb可以按照一定的CSS属性排序规则，将杂乱无章的CSS属性进行重新排序。选中要排序的CSS代码，按Ctrl+Shift+C，即可对CSS属性重新排序了，代码从此简洁有序易维护，如果不款选代码则插件将排序文件中所有的CSS属性。当然，可以自己自定义CSS属性排序规则，打开插件目录里的CSScomb.sublime-settings文件，更改里面的CSS属性顺序就行了。因为这个插件使用PHP写的，要使他工作需要在环境变量中添加PHP的路径，具体请看github上的说明。</p>
<p><strong><a href="https://github.com/kairyou/SublimeTmpl" target="_blank" rel="external">SublimeTmpl 快速生成文件模板</a></strong><br>一直都很奇怪为什么sublime text 3没有新建文件模板的功能，像html头部的DTD声明每次都要复制粘贴。用SublimeTmpl这款插件终于可以解脱了，SublimeTmpl能新建html、css、javascript、php、python、ruby六种类型的文件模板，所有的文件模板都在插件目录的templates文件夹里，可以自定义编辑文件模板。<br>SublimeTmpl默认的快捷键:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ctrl+alt+h <span class="tag">html</span></span><br><span class="line">ctrl+alt+j javascript</span><br><span class="line">ctrl+alt+c css</span><br><span class="line">ctrl+alt+<span class="tag">p</span> php</span><br><span class="line">ctrl+alt+r ruby</span><br><span class="line">ctrl+alt+shift+<span class="tag">p</span> python</span><br></pre></td></tr></table></figure></p>
<p>如果想要新建其他类型的文件模板的话，先自定义文件模板方在templates文件夹里，再分别打开Default (Windows).sublime-keymap、Default.sublime-commands、Main.sublime-menu、SublimeTmpl.sublime-settings这四个文件照着里面的格式自定义想要新建的类型，这里就详细介绍了，请各位自己折腾哈~</p>
<p><strong><a href="https://github.com/Pleasurazy/Sublime-JavaScript-API-Completions" target="_blank" rel="external">Javascript-API-Completions</a></strong>:<br>支持Javascript、JQuery、Twitter Bootstrap框架、HTML5标签属性提示的插件，是少数支持sublime text 3的后缀提示的插件，HTML5标签提示sublime text3自带，不过JQuery提示还是很有用处的，也可设置要提示的语言。<br><img src="http://www.jeffjade.com/img/toss/sublime-plugin-jq.gif" alt="sublime-jq-plugin"></p>
<p><strong>SFTP：快速编辑远程服务器文件</strong><br>在Win下用<code>Xftp</code> 和 <code>WinScp</code>，被这种需要切换点击or F5刷新的手动操作蛋疼到无语；故此一遇见这<code>SFTP</code>，顿觉这世界都美好了许多。当然Sublime下面也有些其他同步插件，比如<code>FtpSnyc</code>，但是配置起来的错误提示一点都不人性化，就毫不留情的舍弃了。Sublime下有<code>SFTP</code>，只要<code>Ctrl+S</code>即可同步本地到服务器，妥妥的爽歪歪有么有？如何配置，请参见<a href="http://blog.wpjam.com/m/sublime-text-2-sftp/" target="_blank" rel="external">在 Sublime Text中使用 SFTP 插件快速编辑远程服务器文件</a>;如欲使用<code>FtpSync</code>可参见<a href="http://liuwanlin.info/sublimeshi-yong-ji-ftpsyncyuan-cheng-tong-bu/" target="_blank" rel="external">Sublime使用及FtpSync远程同步</a>；大道至简，因简而悦；开心垒码，值得折腾。</p>
<p><strong><a href="https://wakatime.com" target="_blank" rel="external">WakaTime</a></strong> — 记录你的Code时间;<br><a href="https://wakatime.com/" target="_blank" rel="external">WakaTime</a>可以做到精确地统计到你花在某个项目上的时间;WakaTime针对不同的IDE，拥有不同的插件，在Sublime上安装着<a href="https://wakatime.com/help/plugins/sublime" target="_blank" rel="external">插件</a>，就能统计到我使用Sublime进行的所有项目的行为。可以高效管理和知晓自己code时间；并且，统计完善, 适合发朋友圈装逼（如果你喜欢的话）~</p>
<blockquote>
<p>Waka的基本设计和rescuetime类似。每个人注册完将获取一个key，装一个客户端，把key输进去（登陆是同一个道理），然后它就把本地的所有行为带个key扔给服务器来统计，一段时间之后给你个报表。不过Waka做的真的很精准，精确到每一个文件用了多少秒，每一种语言用了多少时间。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/82950-b9d7380d0608ecb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>安装和使用都很简单，请参见<a href="https://wakatime.com/help/plugins/sublime-text" target="_blank" rel="external">这里</a>。另外一篇比较详细的文章<a href="https://luolei.org/track-your-time/" target="_blank" rel="external">时间都去哪了?用RescueTime和WakaTime来记录你的时间</a>,对RescueTime和WakaTime有一个更为详细的叙述，可以一读。</p>
<p>剩下些许其他的可以按需安装的插件，比如：</p>
<ul>
<li><strong>ConvertToUTF8</strong>  支持 GBK, BIG5, EUC-KR, EUC-JP, Shift_JIS 等编码的插件</li>
<li><strong>Bracket Highlighter</strong> 用于匹配括号，引号和html标签。对于很长的代码很有用。安装好之后，不需要设置插件会自动生效</li>
<li><strong>DocBlockr</strong> 可以自动生成PHPDoc风格的注释。它支持的语言有Javascript, PHP, ActionScript, CoffeeScript, Java, Objective C, C, C++</li>
<li><strong><font color="purple">Emmet(Zen Coding)</font></strong>快速生成HTML代码段的插件，强大到无与伦比:可以超快速编写HTML/CSS/JS，当然这个插件还支持多种编译环境，如常见的：Eclipse/Aptana、Coda、Notepad++、Adobe Dreamweaver、TextMate等，<strong>web开发必备！！！</strong>。</li>
<li><strong>jsFormat</strong> 格式化js代码，懂者自懂；强迫症Coder必备！默认快捷键Ctrl+Alt+F。</li>
<li><strong>phpFormat</strong> 格式化php代码，懂者自懂；强迫症Coder必备！</li>
<li><strong>CSS Compact Expand CSS属性展开收缩:</strong>写CSS的盆友，喜欢将其写多行还是一行(个人喜欢将其格式化为多行)？如果阅读别人的代码不符合自己的习惯，可以用CSS Compact Expand这个插件将CSS格式化一下，按 Ctrl+Alt+[ 收缩CSS代码为一行显示，按 Ctrl+Alt+] 展开CSS代码为多行显示；强迫症Coder必备！。</li>
<li><strong>Autoprefixer插件</strong>：这是一款CSS3私有前缀自动补全插件；该插件使用CanIUse资料库（当然，SublimeText自然也有<font color="purple">CanIUse</font>这个插件咯），能精准判断哪些属性需要什么前缀，与CssComb插件一样，该插件也需要系统已安装Node.js环境；使用方法：在输入CSS3属性后（冒号前）按Tab键即可。</li>
<li><strong>YUI Compressor</strong>：压缩JS和CSS文件，按F7键后，若压缩当前文件（demo.js），则压缩后的文件（demo.min.js）保存在该文件的同级目录，需要安装java的JDK。使用方法：<a href="http://frontenddev.org/article/sublime-does-text-3-plug-in-yui-compressor.html" target="_blank" rel="external">YUI Compressor</a></li>
<li><strong>ClickableURLs：可点击的URL</strong><br>使用小插件<a href="https://github.com/leonid-shevtsov/ClickableUrls_SublimeText" target="_blank" rel="external">ClickableURLs</a>可以让文件中的URL能够点击。</li>
<li><strong>终极王道</strong>：自己编写专用的Sublime Text插件。虽然说各个方面比如移动端，Web前段，服务器端，非Coder的Writer所需要的方便已经被集成在了不同的插件中。但譬如，需要快捷打开PC端的某个模拟器，便捷的进行某些校验，只要你想的到的基本都可以将其在插件内，以快捷键处理之。至于如何编写SublimeText插件，请参看这里<a href="http://www.360doc.com/content/15/0417/22/19342630_463999403.shtml" target="_blank" rel="external">编写自己的Sublime Text2 插件</a></li>
</ul>
<p></p><h2 id="four"><b>定制属于自己的快捷键</b></h2><p></p>
<ul>
<li>首先要会使用SublimeText内置的快捷键：<br>  比如 <code>Commond Shift P</code> 打开命令面板:例如打开Package Control安装各种插件；可以可以输入Set(Snytax)来改变使用的语言环境，瞬间切换等等。</li>
<li><p>设置快捷键。在SublimeText里，打开Preferences -&gt; Key Bindings - User，我设置的快捷键：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"ctrl+f9"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"build"</span> </span>&#125;,</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"f10"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"build"</span></span>, "<span class="attribute">args</span>": <span class="value">&#123;"<span class="attribute">variant</span>": <span class="value"><span class="string">"Run"</span></span>&#125; </span>&#125;,</span><br><span class="line">    &#123; "<span class="attribute">keys</span>": <span class="value">[<span class="string">"ctrl+shift+x"</span>]</span>, "<span class="attribute">command</span>": <span class="value"><span class="string">"toggle_comment"</span></span>, "<span class="attribute">args</span>": <span class="value">&#123; "<span class="attribute">block</span>": <span class="value"><span class="literal">true</span> </span>&#125; </span>&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>  具体可参见这边文章<a href="http://blog.csdn.net/moyan_min/article/details/11530751" target="_blank" rel="external">Sublime Text3 快捷键汇总及设置快捷键配置环境变量</a></p>
</li>
<li><p>定制属于自己的专属快捷键：<br>  比如就拿定制Sublime Text(2/3)编译lua 的快捷键来说：</p>
<ul>
<li><p>首先：下安装lua环境(MAC)</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.py | sudo python - install rudix&#10;&#10;&#25110;&#32773;&#65306;curl -O https://raw.githubusercontent.com/rudix-mac/rpm/2014.10/rudix.py&#10;sudo python rudix.py install rud</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装IED：SublimeText3;完毕后上面选择:Build System—New Build System 输入：</p>
  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    "<span class="attribute">cmd</span>": <span class="value">[<span class="string">"/usr/local/bin/lua"</span>, <span class="string">"$file"</span>]</span>,  </span><br><span class="line">    "<span class="attribute">file_regex</span>": <span class="value"><span class="string">"^(...*?):([0-9]*):?([0-9]*)"</span></span>,  </span><br><span class="line">    "<span class="attribute">selector</span>": <span class="value"><span class="string">"source.lua"</span>  </span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>保存为Lua.sublime-build，然后Tools-Build System上就能选择lua来编译脚本了）<br>PS：网上找到的大多数都是 “cmd”: [“lua”, “$file”]可能我是用rudix自动来安装lua的，需要改一下路径。</p>
<p>新建一个xx.lua文件，随便写个语句，选择lua为build system，按一下<code>command+b</code>，就能跑出来了。 如下图所示：<br><img src="http://img2.ph.126.net/PI2F5lnTuwqeBm7KQx56zw==/1871245645272492575.png" alt="LuaShortCutSublimeText"><br>WindowS下面的定制请参看这里<a href="http://www.cnblogs.com/jadeboy/p/4055465.html" target="_blank" rel="external">Sublime Text(2/3)编译lua</a></p>
</li>
</ul>
</li>
</ul>
<p></p><h2 id="five"><b>Sublime不可不知的实用技巧:</b></h2><br>—-更新2015.05.21 15:50 ShenZhen@nanshan<br>对于这个依赖于插件的强大性感无比开源编辑器；优雅的适用之，就在于合理的使用需要的插件，走一条快准狠的键盘一刀流。这个当然可以自己用python来写，但是一般的需求基本上都已经有人完成，还是不浪费时间自己造轮子了。今儿就再赘述一些使用的经验，让使用她可以更加优雅。<p></p>
<p>(1) Ctrl+O(Command+O)可以实现头文件和源文件之间的快速切换<br>(2) 通过 View -&gt; Side bar 可在左侧显示当前打开的文件列表 </p>
<p>(3) ST3虽然不像notepad++可以在sidebar上显示函数列表，但是可通过Ctrl+R查看 </p>
<p>(3) 通过 Preference -&gt; Key binding user 可根据个人操作习惯自定义快捷键（包括ST3自带的和插件的） </p>
<p>(4) 双击可选中光标所在单词，三击可选中光标所在行(等同于<code>Ctrl＋L</code>(Command+L));</p>
<p>(5) Ctrl+Shift+T可以打开之前关闭的tab页，这点同chrome是一样的</p>
<p>(6)Ctrl+R定位函数；Ctrl+G定位到行；</p>
<p>(7) 单个文件批量修改：<strong>纯相同的内容</strong>：选中需要修改的内容<code>Alt+F3</code>(Mac下默认的是<code>Ctrl+Command+G</code>) ， 或者连续 Ctrl+D(Win) /连续 Command+D（Mac）之后重新写即可，使用<code>Ctrl + U</code>进行回退，使用Esc退出多重编辑。<br><strong>不纯相同却有一定规律可循的内容</strong>：这个就需要借助SublimeText强大正则的支持了。可以使用<code>Ctrl+H</code>(Mac下是<code>Alt+Command+F</code>)调出：<br><img src="http://i.imgur.com/4NnE9SN.jpg" alt="SublimeText"><br>正则表达式是非常强大的文本查找&amp;替换工具，Sublime Text中使用Alt + R切换正则匹配模式的开启/关闭。Sublime Text的使用<a href="http://www.boost.org/doc/libs/1_44_0/libs/regex/doc/html/boost_regex/syntax/perl_syntax.html" target="_blank" rel="external">Boost里的Perl正则表达式风格</a>。鉴于篇幅，加之本身就对这个不甚熟悉，这里就不再多啰嗦；以下是一些可以参考的文章：</p>
<ul>
<li><a href="http://www.oschina.net/question/12_9507" target="_blank" rel="external">开源中国～正则表达式30分钟入门教程</a></li>
<li><a href="http://www.jeffjade.com/2014/12/25/2014-12-25-regular-expression/" target="_blank" rel="external">59分钟学会正则表达式</a></li>
<li><a href="https://msdn.microsoft.com/zh-cn/library/ae5bf541(v=vs.90" target="_blank" rel="external">MSDN～正则表达式语法</a>.aspx)</li>
<li><a href="http://www.williamlong.info/archives/433.html" target="_blank" rel="external">月光博客～常用正则表达式</a></li>
</ul>
<p>(8) 有时我们需要对一片区域的所有行进行同时编辑，<code>Ctrl+Shift+L</code>可以将当前选中区域打散，然后进行同时编辑：<br><img src="http://i.imgur.com/0NHpXFl.gif" alt="SublimeText"></p>
<p>(9)有打散自然就有合并，<code>Ctrl + J</code>(mac下Command＋J)可以把当前选中区域合并为一行：<br><img src="http://i.imgur.com/hfRAyiy.gif" alt="SublimeText"></p>
<p>(10)在<code>Ctrl + P</code>(Command+P)匹配到文件后，我们可以进行后续输入以跳转到更精确的位置：</p>
<ul>
<li>@ 符号跳转：输入<code>@symbol</code>跳转到symbol符号所在的位置</li>
<li># 关键字跳转：输入<code>#keyword</code>跳转到keyword所在的位置</li>
<li>: 行号跳转：输入<code>:12</code>跳转到文件的第12行。</li>
</ul>
<p>(11)<code>Ctrl + Enter</code>(Mac~Command+Enter)在当前行下面新增一行然后跳至该行；<code>Ctrl + Shift + Enter</code>在当前行上面增加一行并跳至该行。</p>
<p>(12)Sublime Text的查找有不同的模式：<code>Alt + C</code>切换大小写敏感（Case-sensitive）模式，Alt + W切换整字匹配（Whole matching）模式，除此之外Sublime Text还支持在选中范围内搜索（Search in selection），这个功能没有对应的快捷键，但可以通过以下配置项自动开启。</p>
<blockquote>
<p>“auto_find_in_selection”: true</p>
</blockquote>
<p>这样之后在选中文本的状态下范围内搜索就会自动开启，配合这个功能，局部重命名（Local Renaming）变的非常方便：<br><img src="http://i.imgur.com/QRIsDra.gif" alt="SublimeText"></p>
<p>(13)Windows下<code>Ctrl + ←/→</code>进行逐词移动，相应的，<code>Ctrl + Shift + ←/→</code>进行逐词选择。<br><img src="http://i.imgur.com/jFnTDl3.gif" alt="SublimeText"><br>而Mac下的<code>Command+←/→</code>是从一端移动到另一端；相应的，<code>Command + Shift + ←/→</code>是从一端选择到另一端。Mac 下 option 加上左右键可以逐词移动；</p>
<p>(14) Windows下<code>Ctrl + ↑/↓</code>移动当前显示区域，<code>Ctrl + Shift + ↑/↓</code>移动当前行。<br><img src="http://i.imgur.com/v31pd3k.gif" alt="SublimeText"><br>而Mac下的<code>Command + ↑/↓</code>是从当前行移动到头/尾；相应的，<code>Command + Shift + ↑/↓</code>是从当前行选择到头/尾；</p>
<p>(15)使用<code>Ctrl + N</code>在当前窗口创建一个新标签，<code>Ctrl + W</code>关闭当前标签，<code>Ctrl + Shift + T</code>恢复刚刚关闭的标签。</p>
<p>(16)编辑代码时我们经常会开多个窗口，所以分屏很重要。Windows下：<code>Alt + Shift + 2</code>进行左右分屏，<code>Alt + Shift + 8</code>进行上下分屏，<code>Alt + Shift + 5</code>进行上下左右分屏（即分为四屏）。</p>
<p>(17)Sublime Text基本的手动格式化操作包括：<code>Ctrl + [</code>向左缩进(等同于将一块选中Shift+Tab)，Ctrl + ]向右缩进(等同于将一块选中后Tab键)，<strong>注解：</strong> Ctr+[ 和 Ctr+[ 针对一块连续内容使用，无需选中；此外Ctrl + Shift + V可以以当前缩进粘贴代码（非常实用）。</p>
<p>(18) <del><code>Ctrl+Shift+V</code></del>(好吧，尝试了下Windows下的这个，目测不行，看来须得安装下<a href="https://github.com/kemayo/sublime-text-2-clipboard-history" target="_blank" rel="external">Clipboard-history</a>插件～（粘贴板历史记录）才行啊)（Mac下Command＋Shift＋V），粘贴之时可以调出之前粘贴过的内容（以一个轻量弹框显示以供选择），哇哦，才发现这个功能，感觉棒棒哒😄😄。<br><img src="http://www.jeffjade.com/img/toss/sublimetext-hotkey.png" alt="SublimeText"></p>
<p>(19) Sublime text 删除插件步骤：“Ctrl+Shift+P”—“Remove Package”—“找到需要删除的插件，并点击即可删除”;</p>
<p>(20) 作为强大而小巧，性感且快捷的SublimeText，怎么能够允许不时弹个框提醒你购买或者别的，并且顶部有未注册这样破坏美感的存在呢？OK，输入<a href="http://www.jianshu.com/p/04e1b65dd2c0" target="_blank" rel="external">Sublime text 3最新版破解方法</a>中提供的注册码，就妥妥的哦了。</p>
<p></p><h2 id="six"><b>定制属于自己的个性化主题</b></h2><br>SublimeText 她不仅仅是作为性感无比，强大可大编辑器的存在；要知道在如今这么靠脸吃饭的时代，她的美者这方面怎么可能不臻至完美呢？Mac和Windows都默认十多种不同风格的主题，想必会有您喜欢😍的。即便没有也没关系，我们可以自己定制自己喜欢的风格主题。<a href="http://tmtheme-editor.herokuapp.com/#/local/Monokai" target="_blank" rel="external">在线制作专属Sublime Text主题</a>。这个网址可以轻松按照自己的意愿制作喜欢的主题。完毕之后将生成的xx.sublime.theme文件，点开Preferences -&gt; Browsr Packages这个，放在这个直属目录之下，即可在Theme处选择这个主题了，亲测没有问题。<p></p>
<p>后记：作为如此便捷的她(Sublime Text3)，值得分享肯定不止这些，在Coding and Writing路上，要继续去发现和发扬她的美，未完待续…<br>—写于2015.04.17 22:49 ShenZhen@nanshan</p>
<hr>
<p></p><h2 id="seven"><b>Sublime锦上添花些许设置</b></h2><br>—-更新2015.08.31 11:59 ShenZhen@nanshan—-<p></p>
<h3 id="Sublime_Text内运行javascript(ES6)"><strong>Sublime Text内运行javascript(ES6)</strong></h3><h4 id="首先安装nodejs">首先安装<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a></h4><p>当然你可以使用其它诸如<a href="https://trac.webkit.org/wiki/JSC" target="_blank" rel="external">jsc</a>之类的环境来运行js, 本文使用的是<a href="http://nodejs.org/" target="_blank" rel="external">nodejs</a>. 首先确保你的电脑已经安装好nodejs, 并已将其添加到环境变量中 (一般安装时自动添加或者询问是否添加)</p>
<h4 id="添加build_system">添加<a href="https://sublime-text-unofficial-documentation.readthedocs.org/en/sublime-text-2/file_processing/build_systems.html" target="_blank" rel="external">build system</a></h4><p>在sublime text中依次打开Tools -&gt; Build System -&gt; New Build System… 粘贴以下代码后保存(如Node.sublime-build), 然后把Build System设成Automatic<br>{ “cmd”: [“node”, “—use-strict”, “—harmony”, “$file”], “selector”: “source.js”}</p>
<h4 id="附加说明">附加说明</h4><p>在以上的build文件中(Node.sublime-build), node是执行命令, —harmony和—use-strict是执行参数, $file是当前文件名, 所以一次build操作实际上相当于在命令行中执行了node —use-strict —harmony filename<br>. —harmony表示启用<a href="http://kangax.github.io/compat-table/es6/" target="_blank" rel="external">ES Harmony features</a>, 而这些features目前只能在strict模式下运行, 所以需要同时添加use-strict参数(详见<a href="http://stackoverflow.com/questions/17253509/what-is-extended-mode" target="_blank" rel="external">what-is-extended-mode</a>).<br>如果不想启用es6的特性,把build文件更改成以下代码保存即可.<br>{ “cmd”: [“node”, “$file”], “selector”: “source.js”}</p>
<h4 id="具体使用">具体使用</h4><p>在sublime test中新建一个test.js文件, 然后输入你的测试代码, 比如:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (let i = 0; i &#60; 3; i++) &#123;&#10;    console.log(&#39;i:&#39;, i);&#10;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用快捷键 <code>ctrl + b</code><br>, 将得到以下执行结果:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">i:</span> <span class="number">0</span><span class="string">i:</span> <span class="number">1</span><span class="string">i:</span> <span class="number">2</span>[Finished <span class="keyword">in</span> <span class="number">0.1</span>s]</span><br></pre></td></tr></table></figure></p>
<p><strong>温馨注解:</strong></p>
<ul>
<li>(1)文件必须是存在于磁盘中的, 而不是untitled的, 否则sublime无法找到相应的文件.</li>
<li>(2)Nodejs安装目录需要加入path环境变量中，否则Ctrl+B运行 会出现：[WinError 2] 系统找不到指定的文件。</li>
</ul>
<h3 id="更换Sublime_Text程序图标"><strong>更换Sublime Text程序图标</strong></h3><p>不仅主题可以更换，图标也可以。在<a href="https://dribbble.com/" target="_blank" rel="external">Dribbble</a>上有大量重新设计的Sublime Text精美图标。更换方法：</p>
<ol>
<li>下载一个图标，有<code>.icn</code>s格式的最好。如果没有，用iConvert转换之。</li>
<li>终端执行：<code>open /Applications/Sublime\ Text.app/Contents/Resources/</code></li>
<li>替换<code>Sublime Text 3.icns</code>或<code>Sublime Text 2.icns</code>文件。<br><img src="http://segmentfault.com/img/bVchAA" alt="Sublime"></li>
</ol>
<h3 id="Sublime_拼写检查"><strong>Sublime 拼写检查</strong></h3><p>如果你经常使用SublimeText从事英文创作，那么启用拼写检查就非常有用处了。选择<code>Preferences &gt; Settings – User</code>菜单，添加以下代码：</p>
<blockquote>
<p>“spell_check”: true,   </p>
</blockquote>
<p></p><h2><b id="eight">写在一路更来的结语</b></h2><br>不得不说的是此篇文章的命名，较之于内容来讲是大了很多。毕竟要优雅使用某个工具，并不是件很容易的事。一边发现学习，一边总结更新，到此已5个月整。然而，对她～SublimeText3三的使用和了解也是仅仅限于一般水平而已。只能说：每个人都工具的使用都怀有不同的态度和追求；但是，<strong>工欲善其事，必先利其器</strong>；此一点总是没错的。因此，在投资自己这里，除学习知识之外，工具的使用大抵就是最应该投资学习的，再次可以是蓝股等等，一如Google工程师@徐宥<a href="http://blog.youxu.info/2008/03/10/tools-everywhere/" target="_blank" rel="external">工具的强是无敌的</a>所言。<p></p>
<p>所谓，一个好汉三个帮；欲要优雅使用一个工具，辅助器具是必不可少的。而在于Win下以SublimeText来编程或者写作，譬如<strong>AutoHotKey</strong>，<strong>Listary</strong>等对个人来讲着实已成必备工具(在Mac下，有Alfred在手，可以说是天下我有)；其给人带来的方便快捷和意想不到的惊喜，足以可以令其称为Win下小众软件中实用最。当然，像<strong>AutoHotKey</strong>这种在乎于人强，其功能愈发强的工具，其修行之路漫漫，还当上下以求索之(15.09.17更)。</p>
<p>当然，也不能盲目停留在SublimeText这孤傲的世界里。虽性感强大如斯，毕竟也已逝老牌儿范儿了。新的时代总会崛起些新秀，比如Github出品的<code>Atom</code>许有赶超Sublime之势，目测充盈着些许不同的理念；有时间定当去学习下，知乎有话题：<a href="http://www.zhihu.com/question/22867204" target="_blank" rel="external">如何评价 Github 发布的文本编辑器 Atom？</a>，可预先了解下。</p>
<p>最后寄语：<br><strong>工欲善其事，必先利其器！</strong><br><strong>公欲善其事，必先利其器！</strong></p>
<p>参考文章出处：<br><a href="http://www.cnblogs.com/figure9/p/sublime-text-complete-guide.html" target="_blank" rel="external">Sublime Text 全程指引 by Lucida</a><br><a href="http://www.cnblogs.com/bugs/p/3533216.html" target="_blank" rel="external">Sublime Text 3能用支持的插件推荐</a><br><a href="http://www.cnblogs.com/Leo_wl/p/4478147.html" target="_blank" rel="external">Wakatime 测试工作时间</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用她来写代码，绝对是一种享受。相比于难于上手的Vim，浮肿沉重的Eclipse，VS，即便体积轻巧迅速启动的Editplus、Notepad++，在SublimeText面前大略显失色，无疑这款性感无比的编辑器是Coding和Writing最佳的选择，没有之一。</p>]]>
    
    </summary>
    
      <category term="SublimeText" scheme="http://jeffjade.github.io/tags/SublimeText/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery VS JavaScript原生API]]></title>
    <link href="http://jeffjade.github.io/2015/11/25/2015-11-31-jQuery-vs-javaScript/"/>
    <id>http://jeffjade.github.io/2015/11/25/2015-11-31-jQuery-vs-javaScript/</id>
    <published>2015-11-24T16:00:00.000Z</published>
    <updated>2015-12-07T13:16:49.000Z</updated>
    <content type="html"><![CDATA[<p>如今技术日新月异，各类框架库也是层次不穷。即便当年<strong>漫山红遍</strong>的JQuery（让开发者<code>write less, do more</code>，So Perfect!!）如今也有<code>被替代</code>的大势。但JS原生API写法依旧；并且有时候只不过小写一个Demo，或者产品中只有少量的前端效果或DOM操作，就去花时间&amp;空间引入jQuery，或者React？不免有取宰牛之刀以杀鸡之嫌。</p>
<a id="more"></a>
<p>在jQuery的温柔乡里，是否还能记得原生她javascript原生？如果仅为使用个选择器($)或者类似的东西，是否真的有必要加载jQuery？故此了解下JS常用原生写法还是蛮有必要的。</p>
<p>[update-2015-12-07]有看到<a href="https://github.com/camsong/blog/issues/4" target="_blank" rel="external">抛弃jQuery，拥抱原生JavaScript</a>一文中提到，jQuery 代表着传统的以 DOM 为中心的开发模式，但现在复杂页面开发流行的是以 React 为代表的以数据/状态为中心的开发模式； React、Angular、Vue 等框架的流行，直接操作 DOM 不再是好的模式，jQuery 使用场景大大减少。</p>
<p><strong><a href="https://lkml.org/lkml/2000/8/25/132" target="_blank" rel="external">Talk is cheap. Show me the code</a></strong>.直接看代码；以下是jQuery和JavaScript实现相同操作的等价代码：</p>
<h3 id="选择元素"><strong>选择元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line"><span class="keyword">var</span> els = $(<span class="string">'.el'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="keyword">var</span> els = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.el'</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 函数法  </span></span><br><span class="line"><span class="keyword">var</span> $ = <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelectorAll(el);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> els = $(<span class="string">'.el'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="创建元素"><strong>创建元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line"><span class="keyword">var</span> newEl = $(<span class="string">'&lt;div/&gt;'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="keyword">var</span> newEl = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="添加/移除/切换类"><strong>添加/移除/切换类</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).addClass(<span class="string">'class'</span>);  </span><br><span class="line">$(<span class="string">'.el'</span>).removeClass(<span class="string">'class'</span>);  </span><br><span class="line">$(<span class="string">'.el'</span>).toggleClass(<span class="string">'class'</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).classList.add(<span class="string">'class'</span>);  </span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).classList.remove(<span class="string">'class'</span>); </span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).classList.toggle(<span class="string">'class'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="判断是否包含类"><strong>判断是否包含类</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery</span></span><br><span class="line">$(<span class="string">'.el'</span>).hasClass(<span class="string">'className'</span>);</span><br><span class="line">$(<span class="string">'.el'</span>).has(<span class="string">'.className'</span>); <span class="comment">//也可以用来 判断是否包含某个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">// 原生方法(1)</span></span><br><span class="line">_hasClass(<span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>), className);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_hasClass</span><span class="params">( elements,cName )</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> !!elements.className.match( <span class="keyword">new</span> <span class="built_in">RegExp</span>( <span class="string">"(\\s|^)"</span> + cName + <span class="string">"(\\s|$)"</span>) );</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 原生方法(2)</span></span><br><span class="line"><span class="keyword">if</span>(el.classList.contains(<span class="string">"someClass"</span>))&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加事件监听器"><strong>添加事件监听器</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).on(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================//  </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line">[].forEach.call(<span class="built_in">document</span>.querySelectorAll(<span class="string">'.el'</span>), <span class="function"><span class="keyword">function</span> <span class="params">(el)</span> </span>&#123;  </span><br><span class="line">  el.addEventListener(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  &#125;, <span class="literal">false</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>原生－DOM绑定事件－优化1<a href="http://www.cnblogs.com/coffeedeveloper/p/4811850.html" target="_blank" rel="external">参考HERE</a></strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM绑定事件-之自执行</span></span><br><span class="line"><span class="keyword">var</span> BindEvent = (<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'addEventListener'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle, ex)</span> </span>&#123;</span><br><span class="line">      dom.addEventListener(event, handle, ex || <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'attachEvent'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle)</span> </span>&#123;</span><br><span class="line">      dom.attachEvent(<span class="string">'on'</span> + event, handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle)</span> </span>&#123;</span><br><span class="line">      dom[<span class="string">'on'</span> + event] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p><strong>原生－DOM绑定事件－优化2</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM绑定事件-之惰性加载(调用方去触发BindEvent之时才去做初始化)//</span></span><br><span class="line"><span class="keyword">var</span> BindEvent = <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle, ex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">'addEventListener'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</span><br><span class="line">    BindEvent = <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle, ex)</span> </span>&#123;</span><br><span class="line">      dom.addEventListener(event, handle, ex || <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'attachEvent'</span> <span class="keyword">in</span> <span class="built_in">document</span>) &#123;</span><br><span class="line">	BindEvent = <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle)</span> </span>&#123;</span><br><span class="line">      dom.attachEvent(<span class="string">'on'</span> + event, handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    BindEvent = <span class="function"><span class="keyword">function</span> <span class="params">(dom, event, handle)</span> </span>&#123;</span><br><span class="line">      dom[<span class="string">'on'</span> + event] = handle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  BindEvent(dom, event, handle, ex);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="设置/获取属性"><strong>设置/获取属性</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).filter(<span class="string">':first'</span>).attr(<span class="string">'key'</span>, <span class="string">'value'</span>);  </span><br><span class="line">$(<span class="string">'.el'</span>).filter(<span class="string">':first'</span>).attr(<span class="string">'key'</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).setAttribute(<span class="string">'key'</span>, <span class="string">'value'</span>);  </span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).getAttribute(<span class="string">'key'</span>);</span><br></pre></td></tr></table></figure>
<h3 id="附加内容（Append）"><strong>附加内容（Append）</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).append($(<span class="string">'&lt;div/&gt;'</span>));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>));</span><br></pre></td></tr></table></figure>
<h3 id="克隆元素"><strong>克隆元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line"><span class="keyword">var</span> clonedEl = $(<span class="string">'.el'</span>).clone();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="keyword">var</span> clonedEl = <span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).cloneNode(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h3 id="移除元素"><strong>移除元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).remove();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line">remove(<span class="string">'.el'</span>);  </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">(el)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> toRemove = <span class="built_in">document</span>.querySelector(el);  </span><br><span class="line">  toRemove.parentNode.removeChild(toRemove);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取父元素"><strong>获取父元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).parent();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).parentNode;</span><br></pre></td></tr></table></figure>
<h3 id="上一个/下一个元素"><strong>上一个/下一个元素</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$(<span class="string">'.el'</span>).prev();  </span><br><span class="line">$(<span class="string">'.el'</span>).next();  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//==========================================================// </span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).previousElementSibling;  </span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'.el'</span>).nextElementSibling;</span><br></pre></td></tr></table></figure>
<h3 id="修改CSS属性"><strong>修改CSS属性</strong></h3><p>总是通过Javascript修改和检索CSS属性，这样会比使用jQuery CSS函数更加简单快速，并且没有任何不必要的代码。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//----设置CSS属性----</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* jQuery */</span></span><br><span class="line">  $(el).css(&#123;</span><br><span class="line">    background: <span class="string">"#FF0000"</span>,</span><br><span class="line"><span class="string">"box-shadow"</span>: <span class="string">"1px 1px 5px 5px red"</span>,</span><br><span class="line">    width: <span class="string">"100px"</span>,</span><br><span class="line">    height: <span class="string">"100px"</span>,</span><br><span class="line">    display: <span class="string">"block"</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">/* 原生 */</span></span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">".main-content"</span>);</span><br><span class="line">el.style.background = <span class="string">"#FF0000"</span>;</span><br><span class="line">el.style.width = <span class="string">"100px"</span>;</span><br><span class="line">el.style.height = <span class="string">"100px"</span>;</span><br><span class="line">el.style.display = <span class="string">"block"</span>;</span><br><span class="line">el.style.boxShadow = <span class="string">"1px 1px 5px 5px red"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="XHR或AJAX"><strong>XHR或AJAX</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery  </span></span><br><span class="line">$.get(<span class="string">'url'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);  </span><br><span class="line">$.post(<span class="string">'url'</span>, &#123;data: data&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;);  </span><br><span class="line"> </span><br><span class="line"><span class="comment">//==========================================================//</span></span><br><span class="line"><span class="comment">// 原生方法  </span></span><br><span class="line"><span class="comment">// get  </span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();  </span><br><span class="line">  </span><br><span class="line">xhr.open(<span class="string">'GET'</span>, url);  </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;  </span><br><span class="line">&#125;  </span><br><span class="line">xhr.send();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// post  </span></span><br><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest()  </span><br><span class="line">  </span><br><span class="line">xhr.open(<span class="string">'POST'</span>, url);  </span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">xhr.send(&#123;data: data&#125;);</span><br></pre></td></tr></table></figure>
<p>参考文章：<a href="http://www.iteye.com/news/28503" target="_blank" rel="external">http://www.iteye.com/news/28503</a><br>英文原文：<a href="http://blog.romanliutikov.com/post/63383858003/how-to-forget-about-jquery-and-start-using-native" target="_blank" rel="external">http://blog.romanliutikov.com/post/63383858003/how-to-forget-about-jquery-and-start-using-native</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今技术日新月异，各类框架库也是层次不穷。即便当年<strong>漫山红遍</strong>的JQuery（让开发者<code>write less, do more</code>，So Perfect!!）如今也有<code>被替代</code>的大势。但JS原生API写法依旧；并且有时候只不过小写一个Demo，或者产品中只有少量的前端效果或DOM操作，就去花时间&amp;空间引入jQuery，或者React？不免有取宰牛之刀以杀鸡之嫌。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://jeffjade.github.io/tags/jQuery/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Gulp探究折腾之路(I)]]></title>
    <link href="http://jeffjade.github.io/2015/11/25/2015-11-25-toss-gulp/"/>
    <id>http://jeffjade.github.io/2015/11/25/2015-11-25-toss-gulp/</id>
    <published>2015-11-24T16:00:00.000Z</published>
    <updated>2015-11-25T13:18:27.000Z</updated>
    <content type="html"><![CDATA[<p><strong>前言:</strong> <code>gulp</code>是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。相比于<code>grunt</code>的频繁 IO 操作，gulp的流操作，能更快地更便捷地完成构建工作。此处仅记录初步折腾中所遇点滴以及待解决的点。</p>
<a id="more"></a>
<h2 id="Gulp折腾之初探"><strong>Gulp折腾之初探</strong></h2><h3 id="折腾之战略上的藐视"><strong>折腾之战略上的藐视</strong></h3><p>回过头看Gulp的折腾历程，使用还是非常简易的。初步入门资料可参考<a href="#refer">这里</a>。所以战略上一定要藐视”她”;当然战术上要给予足够的重视。毕竟要依赖她以及其他各种插件and编辑器等实现前端<strong>工程化，组件化，模块化，便捷化</strong>是一个蛮复杂的过程。总之，折腾伊始需要自信就好，折腾过程带着耐心就好。譬如，想借助gulp压缩美化下js代码，写如下代码于gulpfile.js即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"><span class="keyword">var</span> gNeedDealJsFile = <span class="string">'./js/*.js'</span>; <span class="comment">//javascrip代码存放路径</span></span><br><span class="line"><span class="keyword">var</span> outPut = <span class="string">"./build/"</span>;  <span class="comment">//指定输出文件存放目录</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(gNeedDealJsFile)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(rename(&#123;</span><br><span class="line">            suffix: <span class="string">'.min'</span></span><br><span class="line">        &#125;))</span><br><span class="line">        .pipe(gulp.dest(outPut));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在gulpfile.js同级目录运行<code>gulp scripts</code>即可；PS:当然前提是您已经安装了nodejs，并且使用npm安装了代码中需要的插件<code>gulp</code>和<code>gulp-uglify</code>与本地。</p>
<h3 id="摒弃了gulp-run()"><strong>摒弃了gulp.run()</strong></h3><p>gulp的API很简单，常用的也就几个：watch, task, dest, src；目前已经摒弃了run方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Default Task:注册缺省任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.run(<span class="string">'jshint'</span>, <span class="string">'scripts'</span>);</span><br><span class="line"></span><br><span class="line">    gulp.watch(workSpace, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        gulp.run(<span class="string">'jshint'</span>, <span class="string">'scripts'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>gulp.run() has been deprecated. Use task dependencies or gulp.watch task triggering instead.</p>
</blockquote>
<p>可以根据<strong>gulp.task(name[, deps], fn)</strong>特性写法替代之。<strong>deps</strong>：(Array)一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。</p>
<blockquote>
<p><strong>注意：</strong> 你的任务是否在这些前置依赖的任务完成之前运行了？请一定要确保你所依赖的任务列表中的任务都使用了正确的异步执行方式：使用一个 callback，或者返回一个 promise 或 stream。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Default Task:注册缺省任务</span></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'jshint'</span> , <span class="string">'scripts'</span>, <span class="string">'watch'</span>]);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="折腾gulp-src()"><strong>折腾gulp.src()</strong></h3><p>Gulp使用<a href="https://github.com/isaacs/node-glob" target="_blank" rel="external">node-glob</a>来从你指定的glob里面获取文件，这里列举下面的例子来阐述，方便大家理解：</p>
<blockquote>
<p>js/app.js 精确匹配文件<br>js/<em>.js 仅匹配js目录下的所有后缀为.js的文件<br>js/</em>/.js 匹配js目录及其子目录下所有后缀为.js的文件<br>!js/app.js 从匹配结果中排除js/app.js，这种方法在你想要匹配除了特殊文件之外的所有文件时非常管用<br>*.+(js|css) 匹配根目录下所有后缀为.js或者.css的文件<br>此外，Gulp也有很多其他的特征，但并不常用。如果你想了解更多的特征，请查看<a href="https://github.com/isaacs/minimatch" target="_blank" rel="external">Minimatch</a>文档。</p>
</blockquote>
<p>js目录下包含了压缩和未压缩的JavaScript文件，现在我们想要创建一个任务来压缩还没有被压缩的文件，我们需要先匹配目录下所有的JavaScript文件，然后<strong>排除后缀为.min.js的文件</strong>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp.src([<span class="string">'js/**/*.js'</span>, <span class="string">'!js/**/*.min.js'</span>])</span><br></pre></td></tr></table></figure></p>
<h3 id="使用gulp-jshint()"><strong>使用gulp-jshint()</strong></h3><p>好吧，不同帮派，不同侠士，对于代码的输出是不一致的。而这JS又没像Py那般天生带有美丽的基因。即便出了jshint这样的好利器，然，也得考虑下兼顾团队已有的Style。所以，这里配置得纠结下,<a href="https://www.zybuluo.com/mdeditor#200574" target="_blank" rel="external">微说Gulp之gulp-jshint</a>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'lint'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> gulp.src(workSpace)</span><br><span class="line">		.pipe(jshint())</span><br><span class="line">		.pipe(jshint.reporter(<span class="string">'YOUR_REPOTER_HERE'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这reporter使用”default”的话，就会采用默认蛮严格的检查手段。为了能够规范而不失灵活的撸起JS，在使用JShint之时，过滤掉哪些不合时宜的写法(如下写法就可以不留情的规避之)，就得斟酌下咯。列举些常见不推荐的写法，运行时提醒如下：</p>
<blockquote>
<p>Missing semicolon. (W033)  //丢失分号<br> [‘lack’] is better written in dot notation  //推荐xx.lack写法，而不是xx[‘lack’]<br> You might be leaking a variable (disX) here. (W120) //不推荐连等写法：比如posX = disX = 0;<br> ‘status’ is defined but never used. (W098) //不推荐：定义之而不用之<br> Use ‘!==’ to compare with ‘’. (W041) //不推荐 “!=”或者”==”做变量是否相等判断。</p>
</blockquote>
<p> <strong>只对发生更改的 js 文件进行语法检测</strong></p>
<p> 更现实的开发场景是， 项目代码已存在很久，代码中有大量的不符合 jshint 规范的代码。 而根据当前的 gulp 配置，每次发生修改，都会全量检测一遍所有的文件的语法问题，实际上已存在的问题我并不想在本次提交中修复（同时也是其他同事写的，例如不加分号问题，改动量太大）。</p>
<p>结果就是，一启动 gulp，哗哗的语法错误提示，根本找不到自己想看的文件检测结果。这时修改一个文件，又对所有文件做了一次全量检测，又是哗哗的满屏错误提示。而我只关心当前修改的文件检测结果。</p>
<p>gulp 项目首页推荐了一个<strong>gulp-cached</strong>插件，正好解决了这个问题。<br><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-cached --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure></p>
<p>配置如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    cache = <span class="built_in">require</span>(<span class="string">'gulp-cached'</span>),</span><br><span class="line">    jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'jshint'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'./src/**/*.js'</span>)</span><br><span class="line">        .pipe(cache(<span class="string">'jshint'</span>))</span><br><span class="line">        .pipe(jshint())</span><br><span class="line">        .pipe(jshint.reporter(<span class="string">'default'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'./src/**/*.js'</span>, [<span class="string">'jshint'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'jshint'</span>, <span class="string">'watch'</span>]);</span><br></pre></td></tr></table></figure></p>
<p>这样就能清晰的看到刚才<strong>发生修改文件</strong>的语法检测结果了,欧耶。</p>
<h3 id="压缩-合并-重命名-输出~JS代码"><strong>压缩-合并-重命名-输出~JS代码</strong></h3><p><strong>压缩</strong>：<code>gulp-uglify</code>,挺好;<br>Ps： 有一款<code>gulp-minify</code>(Desc: Minify JavaScript with UglifyJS2)，默认压缩完毕之后会生成一个带<code>-min</code>的文件，略烦。</p>
<p><strong>合并</strong>：<code>gulp-concat</code>;指定合并生成名字即可：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.pipe(concat(<span class="string">'all.js'</span>))</span><br></pre></td></tr></table></figure></p>
<p><strong>重命名</strong>: <code>gulp-rename</code>;可以仅仅为名字指定后缀(不改变文件后缀)Like This:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.pipe(rename(&#123;suffix: <span class="string">'.min'</span>&#125;))</span><br></pre></td></tr></table></figure></p>
<p><strong>输出</strong>: gulp自带方法<code>gulp.dest</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//outPutPathName: String</span></span><br><span class="line">.pipe(gulp.dest(outPutPathName));</span><br></pre></td></tr></table></figure></p>
<h3 id="压缩~CSS代码(合并-重命名-输出同上)"><strong>压缩~CSS代码(合并-重命名-输出同上)</strong></h3><p><strong>压缩</strong>： <code>gulp-minify-css</code>;嗯，这个直接将原文件压缩了，默认没有改其名字。如果直接输出到该目录下，会覆盖原文件；若要输出同目录之下，可改改名字再输出,Like this：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.pipe(minifycss())</span><br><span class="line">.pipe(rename(&#123;suffix: <span class="string">'.min'</span>&#125;))</span><br><span class="line">.pipe(gulp.dest(outPut));</span><br></pre></td></tr></table></figure></p>
<p>PS:这个插件(默认)也会帮着干掉注释，过滤掉空类(没有内容的描述)等等。</p>
<h2 id="gulp-load-plugins模块"><strong>gulp-load-plugins模块</strong></h2><p>一般情况下，gulpfile.js中的模块需要一个个加载。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">      .pipe(jshint())</span><br><span class="line">      .pipe(jshint.reporter(<span class="string">'default'</span>))</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(concat(<span class="string">'app.js'</span>))</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，除了gulp模块以外，还加载另外三个模块。</p>
<p>这种一一加载的写法，比较麻烦。使用<code>gulp-load-plugins</code>模块，可以加载package.json文件中所有的gulp模块。上面的代码用gulp-load-plugins模块改写，就是下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    gulpLoadPlugins = <span class="built_in">require</span>(<span class="string">'gulp-load-plugins'</span>),</span><br><span class="line">    plugins = gulpLoadPlugins();</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'js'</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">      .pipe(plugins.jshint())</span><br><span class="line">      .pipe(plugins.jshint.reporter(<span class="string">'default'</span>))</span><br><span class="line">      .pipe(plugins.uglify())</span><br><span class="line">      .pipe(plugins.concat(<span class="string">'app.js'</span>))</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'build'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码假设package.json文件包含以下内容。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">devDependencies</span>": <span class="value">&#123;</span><br><span class="line">      "<span class="attribute">gulp-concat</span>": <span class="value"><span class="string">"~2.2.0"</span></span>,</span><br><span class="line">      "<span class="attribute">gulp-uglify</span>": <span class="value"><span class="string">"~0.2.1"</span></span>,</span><br><span class="line">      "<span class="attribute">gulp-jshint</span>": <span class="value"><span class="string">"~1.5.1"</span></span>,</span><br><span class="line">      "<span class="attribute">gulp</span>": <span class="value"><span class="string">"~3.5.6"</span></span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="gulp插件的快速安装"><strong>gulp插件的快速安装</strong></h3><p>谈及了基本应用之后，不得不谈下如何快速安装插件(毕竟，合作开发，彼此都能便捷使用，才是王道)。对于所使用的插件可以一个个安装，同时也可以批量安装Like This：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp-concat gulp-uglify gulp-jshint [...] gulp-rename --save-dev</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>—save：将保存配置信息至package.json（package.json是nodejs项目配置文件）；<br>-dev：保存至package.json的devDependencies节点，不指定-dev将保存至dependencies节点；</p>
</blockquote>
<p>为什么要保存至package.json？因为node插件包相对来说非常庞大，所以不加入版本管理，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行<code>npm install</code>，则会根据package.json下载所有需要的包）。</p>
<p>对于这块细节可以参看<a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">gulp详细入门教程</a>；大概来讲就是可以借助<code>npm init</code>命令，按照其一步步提示，输入项目相关信息。完毕之后，加入需要依赖的插件以及版本信息即可(<strong>注意</strong>：这是一个普通json文件，一定得符合json格式；同时需要安装的插件版本也得是 <strong>&lt;=</strong> 线上最新版本)。PS：前文涉及到的插件下载，即可如此配置予以完成：在生成的package.json中加入如下json(2015-10-26日情形):<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">"devDependencies": &#123;</span><br><span class="line">     "gulp-concat": "~2.6.0",</span><br><span class="line">     "gulp-uglify": "~1.4.2",</span><br><span class="line">     "gulp-jshint": "~1.11.2",</span><br><span class="line">     "gulp-rename": "~1.2.2",</span><br><span class="line">     "gulp-minify-css": "~1.2.1",</span><br><span class="line">     "gulp-cached": "~1.1.0",</span><br><span class="line">     "gulp": "~3.9.0"</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>如此，其他开发者只需更新gulpfile.js以及这个package.json，运行<code>npm install</code>即可下载gulp所依赖插件于本地，(<em>@ο@</em>) 哇～So Cool。</p>
<h3 id="gulp多项目管理(npm_link)"><strong>gulp多项目管理(npm link)</strong></h3><p>要谈下多项目管理了；比如这种场景：对于项目非常多而小，而且彼此间相互独立；伊始，采用在项目根目录之下<code>gulpfile.js</code>和package.json（毕竟每个单独小项目都来一发单独配置，岂不是要疯掉了），会将需要的插件down于根目录下；而在gulpfile.js中控制所要操作的单个小项目路径。这样每次切换项目，都要更改下gulpfile.js,即便将这个分离出来写一个config.js,也得手动去更改，略略有点蛋疼。幸好，gulp有<code>npm link</code>,哇哦，体贴如你，夫复何求？</p>
<p>对于<code>npm link</code>的介绍，可以参见@阮一峰<a href="http://javascript.ruanyifeng.com/nodejs/npm.html#toc15" target="_blank" rel="external">npm模块管理器</a>一文；我们可以将所需的插件，全局环境下载，在单独项目中link全局环境下插件。如此，不仅可以不用每次都down，而且，依赖的插件需要update，只需一地更新，所link之处都会受益。</p>
<p>具体做法，首先将需要的插件全局环境下Down下来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install gulp gulp-concat gulp-rename gulp-uglify  gulp-minify-css gulp-jshint gulp-cached -g</span><br></pre></td></tr></table></figure></p>
<p>接下来，(如果我们要使用gulp-concat这个模块)我们进入单独小项目(eg: gulpTest),使用<code>npm link gulp-concat</code>命令会去【mac/linux】<em>/usr/local/lib/node_modules/</em>, 【window】<em>D:\UserProfiles\username\AppData\Roaming\npm\node_modules</em>,目录下查找名叫<code>gulp-concat</code>的模块，找到这个模块后把该的目录链接到 ~/work/**/gulpTest/node_modules/gulp-concat 这个目录上来。如此，在此项目小项目中的gulpfile.js中也可以加以使用了。当然，<code>npm link</code>也支持多个参数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm link gulp gulp-concat gulp-rename gulp-uglify  gulp-minify-css gulp-jshint gulp-cached</span><br></pre></td></tr></table></figure></p>
<p>PS:这样使用时，需要注意忽略掉node_modules目录下的js/css代码，gulp.src参数数组中可以加入<code>&#39;!node_modules/**/*.+(js|css)&#39;</code>以过滤之。</p>
<hr>
<p><strong>注:</strong>即便使用<code>npm link</code>感觉也不是一个特别<strong>简洁</strong>的方案。并且在使用的时候还遇到了些许问题: 之前有提问于@segmentFault<a href="http://segmentfault.com/q/1010000003969179" target="_blank" rel="external">gulp如何管理多项目？</a> 以及@V2EX <a href="https://www.v2ex.com/t/234896#reply14" target="_blank" rel="external">gulp如何管理多项目</a>;热心码友也提出了一些可行的建议，比如：配置多个task，或者采用<code>fbi</code>，或者采用<code>nodejs 中的 NODE_PATH</code>@<a href="http://segmentfault.com/a/1190000002478924" target="_blank" rel="external">nodejs 中的 NODE_PATH</a>等等;此处有待进一步学习&amp;折腾&amp;择决; (如有简洁方案，欢求指点，拜谢)。</p>
<hr>
<h3 id="gulp-util幸之助"><strong>gulp-util幸之助</strong></h3><p><strong>幸亏有gulp-util之协助</strong>：在折腾的过程中，难免不会出现奇奇怪怪的问题；然而gulp本身的报错提示机制真心让新手的我蛋蛋的忧伤：比如在折腾的过程中压缩JS代码就出现<code>Uglify throws Parse error</code>;可是提示却…幸好@stackoverflow<a href="http://stackoverflow.com/questions/28003104/uglify-throws-parse-error" target="_blank" rel="external">Uglify throws Parse error</a>一个问答中，大牛给予了明灯般的指导：引入<code>gulp-util</code>;原话如下：</p>
<blockquote>
<p><code>uglify</code> will parse the script content before minifying it. I suspect that one of the <code>browserify</code> source maps are being included in the stream down to <code>uglify</code>. Anyway to find the problem you can use <code>gulp-util</code>‘s log method to handle uglify’s exceptions. Example:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> gulpUtil = <span class="built_in">require</span>(<span class="string">'gulp-util'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        .pipe(sourcemaps.init(&#123;loadMaps: <span class="literal">true</span>&#125;))</span><br><span class="line">        .pipe(uglify().on(<span class="string">'error'</span>, gulpUtil.log)) <span class="comment">// notice the error event here</span></span><br><span class="line">        .pipe(sourcemaps.write(<span class="string">'./'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'./web/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="实时刷新页面"><strong>实时刷新页面</strong></h3><h4 id="gulp-livereload模块"><strong>gulp-livereload模块</strong></h4><p><code>gulp-livereload</code>模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中安装插件，用来配合源码变化。</p>
<p><a href="http://livereload.com/" target="_blank" rel="external">LiveReload</a>结合了浏览器扩展（包括Chrome extension），在发现文件被修改时会实时更新网页。它可以和gulp-watch插件或者前面描述的gulp-watch()函数一起使用。下面有一个<code>gulp-livereload</code>仓库中的README文件提到的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>),</span><br><span class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>),</span><br><span class="line">    watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'less'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   gulp.src(<span class="string">'less/*.less'</span>)</span><br><span class="line">      .pipe(watch())</span><br><span class="line">      .pipe(less())</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'css'</span>))</span><br><span class="line">      .pipe(livereload());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这会监听到所有与less/*.less相匹配的文件的变化。一旦监测到变化，就会生成css并保存，然后重新加载网页.</p>
<h4 id="BrowserSync"><strong><a href="https://www.npmjs.com/package/browser-sync#requirements" target="_blank" rel="external">BrowserSync</a></strong></h4><p><strong>安装 BrowserSync</strong><br>您可以选择从Node.js的包管理（NPM）库中 安装BrowserSync。打开一个终端窗口，运行以下命令：</p>
<blockquote>
<p>npm install -g browser-sync</p>
</blockquote>
<p>您告诉包管理器下载BrowserSync文件，并在全局下安装它们，您可以在所有项目(任何目录)中使用。</p>
<p>当然您也可以结合gulpjs或gruntjs构建工具来使用，在您需要构建的项目里运行下面的命令:</p>
<blockquote>
<p>npm install —save-dev browser-sync</p>
</blockquote>
<p><strong><a href="http://www.browsersync.cn/#install" target="_blank" rel="external">启动 BrowserSync</a></strong><br><strong>静态网站</strong><br>如果您想要监听.css文件, 您需要使用服务器模式。 BrowserSync 将启动一个小型服务器，并提供一个URL来查看您的网站。</p>
<blockquote>
<p>// —files 路径是相对于运行该命令的项目（目录）<br>browser-sync start —server —files “css/*.css”</p>
</blockquote>
<p>如果您需要监听多个类型的文件，您只需要用逗号隔开。例如我们再加入一个.html文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// --files 路径是相对于运行该命令的项目（目录） </span></span><br><span class="line">browser-sync start --server --files <span class="string">"css/*.css, *.html"</span></span><br><span class="line"><span class="comment">// 如果你的文件层级比较深，您可以考虑使用 "**"（表示任意目录）匹配，任意目录下任意.css 或 .html文件。 </span></span><br><span class="line">browser-sync start --server --files <span class="string">"**/*.css, **/*.html"</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>在该文件下运行命令，默认需要启动网站文件：index.html。</p>
<p><strong>动态网站</strong><br>如果您已经有其他本地服务器环境PHP或类似的，您需要使用<strong><em>代理模式</em></strong>。 BrowserSync将通过代理URL(localhost:3000)来查看您的网站。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主机名可以是ip或域名</span></span><br><span class="line">browser-sync start --proxy <span class="string">"主机名"</span> <span class="string">"css/*.css"</span></span><br></pre></td></tr></table></figure></p>
<p>在本地创建了一个PHP服务器环境，并通过绑定Browsersync.cn来访问本地服务器，使用以下命令方式，Browsersync将提供一个新的地址localhost:3000来访问Browsersync.cn，并监听其css目录下的所有css文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browser-sync start --proxy <span class="string">"Browsersync.cn"</span> <span class="string">"css/*.css"</span></span><br></pre></td></tr></table></figure></p>
<p>参考博文：<a href="http://acgtofe.com/posts/2015/03/more-fluent-with-browsersync/" target="_blank" rel="external">BrowserSync，迅捷从免F5开始</a>。</p>
<hr>
<p><strong>注</strong>：使用的时候纯路径比如”Browsersync.cn”尚好着，然而地址后面带一堆参数时候，就会遇到些问题；暂时还未搞明白以解决之，特注之，待弄懂！！</p>
<hr>
<h3 id="前端组件html模板化(gulp-tlp2mod)"><strong>前端组件html模板化(gulp-tlp2mod)</strong></h3><p>参考博文：<a href="https://github.com/itbeihe/component-html-engine-demo" target="_blank" rel="external">component-html-engine-demo</a>有叙述有Demo，帮了大忙。</p>
<p>为了前端代码的模块化，必要将JS逻辑代码于布局模板代码分离开来（当然还有CSS以及静态资源也都当分离）；初来乍到，遇到问题了，如何<strong>把tpl转变成js呢？</strong>，OK既然用了构建工具，那么自然也有对应的插件吧，果然 <a href="https://github.com/supersheep/gulp-tpl2mod" target="_blank" rel="external">gulp-tpl2mod</a>~<strong>模板文件转js插件</strong>;再借助require.js, 先使用gulp-tpl2mod把模板转换成js字符串，然后包装成一个模块，再main.js中引用这个模块就行了，大功告成；如此，项目工程化又前进一步。</p>
<h2 id="refer" style="font-weight:bold">折腾之入门所参考文章资料</h2>

<p><a href="http://www.gulpjs.com.cn/docs/api/" target="_blank" rel="external">gulp API 文档</a><br><a href="http://markpop.github.io/2014/09/17/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/" target="_blank" rel="external">Gulp入门教程</a><br><strong><a href="http://www.w3ctech.com/topic/134" target="_blank" rel="external">Gulp开发教程（翻译）</a></strong><br><strong><a href="http://javascript.ruanyifeng.com/tool/gulp.html" target="_blank" rel="external">Gulp：任务自动管理工具</a></strong><br><a href="http://segmentfault.com/a/1190000000372547" target="_blank" rel="external">前端构建工具gulp入门教程</a><br><a href="http://colobu.com/2014/11/17/gulp-plugins-introduction/" target="_blank" rel="external">gulp plugins 插件介绍</a><br><strong><a href="http://www.ydcss.com/archives/18" target="_blank" rel="external">gulp详细入门教程</a></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>前言:</strong> <code>gulp</code>是前端开发过程中对代码进行构建的工具，是自动化项目的构建利器；她不仅能对网站资源进行优化，而且在开发过程中很多重复的任务能够使用正确的工具自动完成；使用她，我们不仅可以很愉快的编写代码，而且大大提高我们的工作效率。相比于<code>grunt</code>的频繁 IO 操作，gulp的流操作，能更快地更便捷地完成构建工作。此处仅记录初步折腾中所遇点滴以及待解决的点。</p>]]>
    
    </summary>
    
      <category term="Gulp" scheme="http://jeffjade.github.io/tags/Gulp/"/>
    
      <category term="NodeJs" scheme="http://jeffjade.github.io/tags/NodeJs/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[CSS实现水平|垂直居中漫谈]]></title>
    <link href="http://jeffjade.github.io/2015/11/14/2015-11-14-css-achieve-horizontal_vertical_center/"/>
    <id>http://jeffjade.github.io/2015/11/14/2015-11-14-css-achieve-horizontal_vertical_center/</id>
    <published>2015-11-14T09:30:00.000Z</published>
    <updated>2016-01-06T13:19:46.000Z</updated>
    <content type="html"><![CDATA[<p>利用CSS进行元素的水平居中，比较简单，手到擒来：行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。而撸起垂直居中，相信于大多初撸者来说，与我相似，内心是抗拒的。于此，以我司同事一内部分享为基，加以搜集完善，得8种CSS垂直居中书写之法；个中有示例Demo，以及代码和优劣之评。<br><a id="more"></a></p>
<p><ul></ul></p>
<p><li><a href="/special/horizontal_center-methods.html" style="font-size:1em;font-weight:blod">CSS实现水平居中(3法)</a><br></li></p>
<p><li><a href="/special/vertical_center_methods.html" style="font-size:1em;font-weight:blod">CSS实现垂直居中(8法)</a><br></li></p>
<p><li><a href="/special/textVerticalCenter.html" style="font-size:1em;font-weight:blod">CSS文本垂直居中(5法)[Update: 2016-01-06]</a><br></li><br><br>PS：窃以为，对于CSS足够熟悉的话，以CSS多种属性组合出的“奇技淫巧”想必是层次不穷的，这里也只是搜集整理了其中为大家常用而又简洁的部分而已。</p>
<hr>
<p><strong>注解:</strong> 好吧，周末被“加班”了耶，搞搞需求整整Blog还算闲适；在写居中示例时，搜肠刮肚没什么适宜之词，便逼的自己“什兴大发“，特胡驺几句自黑乱言，填充内容，耶聊以慰籍；贴之于下，祈与同道者共嗨 😄。</p>
<pre>
    周末把码黄昏后，有咸香盈袖。
    莫道不消魂，独弄键盘，人比黄花瘦。
    真可谓：天堂有路你不走，学海无涯苦作舟。
    到头来：码山有路勤为径？三十功名尘与土。
    饶上个：一入'哀啼'深似海，从此'逍遥'没长'苏'。
</pre>

<p>—更新于2015-11-25 之后在CodePen有看到一文将<strong>绝对居中</strong>阐述的更为全面，链接如下：<br><a href="http://codepen.io/shshaw/full/gEiDt" target="_blank" rel="external">http://codepen.io/shshaw/full/gEiDt</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>利用CSS进行元素的水平居中，比较简单，手到擒来：行级元素设置其父元素的text-align center，块级元素设置其本身的left 和 right margins为auto即可。而撸起垂直居中，相信于大多初撸者来说，与我相似，内心是抗拒的。于此，以我司同事一内部分享为基，加以搜集完善，得8种CSS垂直居中书写之法；个中有示例Demo，以及代码和优劣之评。<br>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://jeffjade.github.io/tags/CSS/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[聊聊心中功夫明星榜]]></title>
    <link href="http://jeffjade.github.io/2015/11/07/2015-11-07-share-kungfu-star/"/>
    <id>http://jeffjade.github.io/2015/11/07/2015-11-07-share-kungfu-star/</id>
    <published>2015-11-07T10:30:00.000Z</published>
    <updated>2015-11-09T16:27:11.000Z</updated>
    <content type="html"><![CDATA[<p>见识浅薄，故此必然难以周全。仅以所晓明星作品和人生为基点，个人喜好为腔调来絮叨。耗一日之功来敲打，权作祭奠和分享逝去的功夫片陪伴的那些青葱岁月。若有不妥处，还请见谅。</p>
<a id="more"></a>
<h2 id="中国之骄傲李小龙">中国之骄傲<strong>李小龙</strong></h2><p>李小龙(Bruce Lee；1940 11.27 - 1973.07.20)，一代武术宗师、功夫影帝、截拳道创始人、中国功夫首位推广者、好莱坞首位华人演员。开创性地推动了世界武术和功夫电影的发展;将 KungFu（功夫）一词写入了英文词典，犹擅长：思考&amp;恰恰舞&amp;哲学。</p>
<p>短暂的一生，却波澜壮阔，饶是一部励志史诗；却创造和打破了世界纪录协会多项世界之最。如同一颗耀眼的彗星划过国际武坛&amp;影坛的上空，对现代搏击技击术和电影表演艺术的发展作出了巨大的贡献。他主演的功夫片风行海内外，成万人空巷之盛况，令功夫在全世界皆闻名遐迩。32年人生历程的一现昙花，却仅凭四部半电影缔造了不朽的东方传奇&amp;世界奇迹。</p>
<p>无论是功夫还是影坛届，纵使40余年风雨无他，其神一般的存在，影响力也无出其右，更空前而绝后；实乃“前无古人，后无来者”；奈何英年早逝，怎不“念天地之悠悠，独怆然而涕下”？于此榜单，第一，舍他其谁？<br><img src="http://www.jeffjade.com/img/bruceLee.png" alt="李小龙"></p>
<h2 id="功夫皇帝李连杰">功夫皇帝<strong>李连杰</strong></h2><p>李连杰，1963年4月26日出生于中国北京，英文名Jet Li。著名电影演员、国际功夫巨星、武术家、慈善家、“壹基金”创始人，“国际武联会、中国武术协会、世界武博会”形象大使，新加坡籍华人，第27届香港电影金像奖最佳男主角。</p>
<p>自幼习武，曾勇夺武术比赛五连冠。1980年一部《少林寺》令其一举成名，家喻户晓；而后渐红于亚洲，98年则勇闯好莱坞，努力与实力的结合，自然结出胜利的花果。从影后以自己深厚的武术功底让中华传统武术的美感和实战武打完美结合，塑造了几十个令人赞叹的经典艺术影像，并成功扬名好莱坞打下属于自己的一片天地，在电影的民族和世界特质中达到了高度均衡，因其在体育、电影、公益等领域的显赫成就被世人称为东方传奇影星。</p>
<p>于身体，弘扬健康体魄，心体合一，李连杰先生创有“武极”；对生活,低调稳重，极少绯闻。虽有两次婚姻却无遗怨。对于人生，积极而向善，参禅以礼佛，修心悟道，竭力济世。08年遭遇海啸奇迹生还后，更是热衷于慈善，创有“壹基金”，旨在救助遭遇灾难后的苍生。</p>
<p>于武术或是电影，也都具有自己的见解与哲学。一部文戏～《海洋天堂》诠释出深沉父爱。数十部武侠片更是风靡几代年轻人，曾几何时也引领一波习武浪潮。岁月如歌，年轻不在，却如好酒，愈久弥香。君可看他诠释的黄飞鸿，令狐冲，其动作动如脱兔，静如处子，堪称“翩若惊鸿，婉若游龙”；凌厉温厚，潇洒有型。若论功夫秀出的美感，当推首推李连杰之姿。大特爱之，故排其第二 (想必争议不太大)。</p>
<p><img src="http://imga1.pic21.com/bizhi/131013/02300/s11.jpg" alt="李连杰"></p>
<h2 id="(duang)大哥成龙">(duang)大哥<strong>成龙</strong></h2><p>成龙(Jackie Chan)，原名：陈港生;1954年4月7日生于香港太平山，祖籍山东，大中华区影坛巨星和国际功夫电影巨星，在华人世界享有极高声望与影响。成龙明星之路并不顺遂，从武师到龙套，低迷到走红，亚洲冲进好莱坞，基本都是靠着耐心，协同努力，一路打出来的，活脱脱的一个“拼命三郎”；其艰辛程度难以想象。</p>
<p>1997年香港回归，江泽民在宴会上敬酒时称成龙为“大哥”，从此“大哥”的称呼成为了成龙的代名词[出自～@度娘]。</p>
<p>成龙，不仅在华人圈中声望极高，他从一个默默无名的小戏童一路一路伴着苦与伤“打”成为今日尽人皆知，家喻户晓的国际巨星，实属不易。成龙为华人电影也立下了汗马功劳，功不可没。成龙在日本是家喻户晓的人物。在美国洛杉矶、旧金山和加利福尼亚州都定有成龙日，旧金山影展曾授予他特别杰出奖。</p>
<p>成龙一生过于丰富；作为武打明星，起伏命运，套路更迭，一路“打”过来，最终以诙谐功夫喜剧闻名于世；。不愧“大哥”，美人在怀，桃运多丰；一副沧桑嗓音，有十多首经典歌曲。也是社会活动家、慈善事业家。成龙在华人电影界闯出了自己的一片天，一步一个脚印，他的电影和人生传奇还在续写。于“功夫电影”，其为李小龙之后新时代又一旗帜。于拍电影一个“拼”字而言，更是冠绝海内，绝难再有。只是，排榜过于赞李连杰先生，成龙先生也只好屈居于第三位了。</p>
<p><img src="http://img.chinaluxus.com/pic/arct/2011/12/20/20111220153716605.jpg" alt="成龙"></p>
<h2 id="后起之秀吴京">后起之秀<strong>吴京</strong></h2><p>吴京,1974年出生于北京，满族正黄旗。6岁开始在北京市什刹海体校练习武术，1989年进入北京市武术队从事专业训练，师承吴彬。95年第一部电影袁和平执导的《功夫小子闯情关》，饰演杨学文,至今回味都觉大好(其经历神似李连杰先生)。</p>
<p>在电视剧方面从《太极宗师》中的<strong>杨昱乾</strong>,到《小李飞刀》中的<strong>阿飞</strong>，到《策马啸西风》中的<strong>孟星魂</strong>，到《少林武王》中名将后裔<strong>昙志</strong>…每一部都觉经典，记忆犹新。电影方面《杀破狼》中反派杀手jet，《黑拳》中的高岗，《男儿本色》中“天养生”等等矫健的身受，也磨砺了不错的演技；而且能<strong>正邪兼顾</strong>，毫无违和感，可谓是<strong>功夫影星</strong>中难得一枚。</p>
<p>演而优则导。08年有自导自演《狼牙》，个人是回味了蛮多遍。桥段趣而不诙，交锋假确生感动。15年4月有自导自演《战狼》,大获成功。6月18日，主演的功夫电影《杀破狼2》上映,首日票房拿下7200万元；15年的中国功夫电影，舞台是他吴京的。</p>
<p>2014年08月25日，吴京和谢楠的儿子出生，取名：<strong>吴所谓</strong>[来自@度娘]。</p>
<p>在这个<strong>大哥</strong>已老，<strong>皇帝</strong>也退，<strong>鲜肉</strong>横飞功夫青黄不接的年代；本以为舞台将是甄子丹的了；然而鲜有作品问世。而吴京不仅冠绝电视剧，纵然是<strong>电影</strong>也是愈发出彩；更可贵的是其<strong>演而优则导</strong>之后不错的佳绩，实属难能可贵。排其于第四，争议应该不大。并且，不觉得他那“干脆利落，敏捷辣狠”的身手真的很帅么？</p>
<p><img src="http://pic.yiyingt.com/Stills/vod/2013-05-09/146282.jpg" alt="吴京"></p>
<h2 id="功夫明星甄子丹"><strong>功夫明星甄子丹</strong></h2><p>甄子丹,（Donnie Yen，1963年7月27日出生于中国广东武术世家），武术家、演员、导演。参与多部西方电影的演出与幕后，与成龙、李连杰同为国际知名的华人武打演员，他的导火线，杀破狼，等影视都体现了他犀利的武功，据说他在美国唐人街是一霸。以前的人知道李小龙，现在唐人街知道甄子丹同时他还担任香港李小龙协会理事、世界明星厨师联合会副主席。</p>
<p>1997年自导自演电影《战狼传说》。2002年担任《刀锋战士2》动作指导。曾参演多部影视剧，2009年凭借影片《叶问》荣获第16届北京大学生电影节最佳男演员。2011年主演的《武侠》荣获第48届台湾电影金马奖最佳动作设计。</p>
<p>甄子丹身手，可谓大好；其人既精幕后武指，又擅台前猛打，形象不错，实力超群、身手了得[@新华网之评]。其动作干净利落，<strong>凌厉迅猛</strong>，狠而近毒，爆发力强，充满力度与视觉观赏性，在香港诸多的动作演员和武术指导中可谓独成一派(个人感觉，过于严肃，缺少飒爽潇洒)。单论功夫而言，不输前面三位任何一人，只不过，人也命也，奈何没有漂亮的作品横空出世，也只能感叹：“冯唐易老，李广难封”。故此，排其于吴京之后。</p>
<p><img src="http://www.mzyfz.com/newsimg/20090427161448.jpg" alt="甄子丹"></p>
<h2 id="武林大哥洪金宝">武林大哥<strong>洪金宝</strong></h2><p>洪金宝，1949年1月7日原籍浙江宁波，出生于香港，演员、武术指导、导演、监制、编剧以及龙虎武师。是20世纪80年代香港影坛的“大哥大”、“杂家小子”。洪金宝对电影的涉猎很广，曾经担任的工作包括演员、动作指导、导演、监制、编剧以及龙虎武师。曾获得香港电影金像奖最佳男主角奖、亚太影展最佳男主角奖等荣誉。</p>
<p>洪金宝是位多才多艺的动作巨星，而且独具慧眼，在演员、动作指导、导演、监制等方面都取得了卓越成就。他努力、勤奋、敬业、大度，将传统的道德观和崭新的武术理念融会贯通到影片之中，强调人与人之间的朴实情感。他对香港电影贡献良多，带动了香港黑色功夫喜剧片以及时装动作片的潮流（@央视网评）。</p>
<p>洪金宝作品，品尝的不是很多，却破为喜欢。黑色功夫喜剧给人蛮多轻松愉悦的快感。沙场老将，这个年纪仍旧操刀，不容易。而且，他老人家这体型，纵使在年轻的时候，即便翻个跟斗，也比平常人多出出几分好彩来，可谓武行一朵灿烂奇葩(褒义绝对)；怎能不从优揶？</p>
<p><img src="http://www.nmplus.hk/home/wp-content/uploads/2014/11/2_resize6-800x534.jpg" alt="洪金宝"></p>
<h2 id="大帅哥儿赵文卓">大帅哥儿<strong>赵文卓</strong></h2><p>93年，赵文卓参演电影《功夫皇帝方世玉》，那时他19岁。01，02以及03年，分别主演武侠电视剧《风云雄霸天下》《大醉侠》,古装剧《至尊红颜》,那时候看他的作品，被迷的“不要不要的”；时而折枝伪剑，时而削木为剑，闲则随舞，剧间而狂；至今仍不时浮现。</p>
<p>赵文卓本名赵卓，他是风靡亚太惊艳北美的型男「真功夫巨星」。赵文卓俊朗的外形、高强的功夫、爽朗大方的男子汉气概深受海内外观众着迷喜爱。父亲是武术教练，母亲是田径国手，8岁其父即送他从师学习武术，曾是哈尔滨市武术队的成员，擅长于剑、枪和拳术，精通太极拳法，能耍三百多套拳法。1990年考进北京体育大学武术系接受武术训练，从12岁起，即获得大小奖项无数。曾获中国全国锦标赛少年冠军、中国全国大学生比赛全能冠军、全国武术冠军(1991年)和当选中国国家武英级运动健将。1992年获元奎导演赏识进入影视圈拍戏大展拳脚功夫。</p>
<p>1995年，赵文卓在拍摄《满汉全席》时与张国荣建立深厚友谊，经张国荣介绍与梅艳芳相识并相恋，但仅一年就分开了。梅艳芳曾表示如果不是神秘原因，她早已成为“赵太太”。而这个真正的神秘原因，至今没有公开。赵文卓曾说，要对至爱负责，不会将这个秘密公布[From@度娘] 。</p>
<p>其外形俊朗，身受矫健，眉宇间的正气凛然，大为符合心中的“侠客”。并且有作品有品格，实是功夫明星中靓玉一块。唯欠缺集一大成于身，多少有些减分。故只能排名于此了。</p>
<p><img src="http://images.china.cn/news/attachement/jpg/site3/20120303/1285723501583775570.jpg" alt="赵文卓"></p>
<h2 id="功夫美女杨紫琼">功夫美女<strong>杨紫琼</strong></h2><p>杨紫琼（Michelle Yeoh）女，1962年8月6日出生于马来西亚怡保，华人演员，制片人。杨紫琼,并不是从小就开始练武，她生于马来西亚，而且曾当选过“马来西亚小姐”，并曾被香港富豪导演潘迪生心仪迎娶，但后来感情告终。她是不恃姿色，而是走严正演员路线的杰出影星。长期苦练动作片演技，武打动作不仅高难、而且到位，是每一位香港影人都尊敬的阿姐级影星，是香港武打片动作女星的杰出代表，与成龙、李连杰、洪金宝平起平坐，而且在美国也成为很受欢迎的香港影星 ，据传当年日本女打星大岛由加利专门来华挑战杨紫琼结果以失败告终。</p>
<p>她通过“拳脚刀枪”的刻苦敬业塑造了一系列武打片中的形象：《超级警察》中与成龙一起打入黑帮的女警、《明日帝国》中首位亚洲邦德女郎、《卧虎藏龙》中飞檐走壁的江湖女子、《天脉传奇》中背负家族千年命运捍卫宝藏的女中豪杰，以及《飞鹰女侠》中飞越长城的女侠。杨紫琼扮演的角色大都刚强坚毅、成熟聪慧，为“侠骨柔情”做出了很好的诠释。</p>
<p>明明是可以靠脸吃饭的她，却选择了结缘“武打”。于千万女性中，独树一帜。拥抱力量而不失优雅，坚强自信大具芳华，用这人生诠释了一个“东方女侠”，堪称“武林”霸气一姐。<br><img src="http://image72.360doc.com/DownloadImg/2014/05/2301/41851821_6.jpg" alt="杨紫琼"></p>
<h2 id="功夫绿叶于海">功夫绿叶<strong>于海</strong></h2><p>于海，1942年7月18日出生于山东烟台，中国武术家、演员。1954年，拜七星螳螂拳大师林景山先生为师，学习正宗的螳螂拳，历经坎坷，终有成就。</p>
<p>1982年，同武打明星李连杰共同拍摄了由张鑫炎导演执导的武打影片《少林寺》，在剧中于海饰演师父，并兼任该片之动作武术指导。95年@<strong>吴京</strong>处女电影《功夫小子闯情关》，他演绎杨学文(@吴京试)，武艺高超，还不失情调；99年同吴京共同拍摄由张鑫炎导演执导的武打电视剧《新少林寺》，在该影片中于海饰演“一代宗师”昙宗。即便近些年刘德华，成功版本《新少林寺》，他饰演师傅…。这仅仅是记得的那一点，还有一堆不知道的。在功夫电影中，于海师傅，也是一朵永远盛开的花～名字叫“绿叶”！</p>
<p>事实上，于海并非专业演员，银幕上的他飞檐走壁，十八般武艺样样精通，塑造出一个个鲜活的“宗师”形象。性格上，于海性格耿直，凡事随缘而行，随遇而安。多年的武学修为加之对角色的悉心揣摩，让他成为武术界、影视界德高望重的前辈（新华网评价）。</p>
<p><img src="http://www.nicholastse.hk/files/news/p---2.jpg" alt="于海"></p>
<h2 id="功夫老哥刘家良">功夫老哥<strong>刘家良</strong></h2><p>刘家良，1934年7月28日出生于广东省广州市，中国香港导演，武术指导。南派功夫洪家拳的嫡系传人。9岁开始随父亲学武，父亲刘湛是黄飞鸿入室弟子林世荣的亲传弟子。50年代中期刘家良随父进入电影界，演过数以百计的电影，仅黄飞鸿系列就演了几十部，成名作是1965年长城公司的《云海玉弓缘》。</p>
<p>1974年，他与张彻合作在《方世玉与洪熙官》一片中展开正宗国术的路线。但在同年，离开张彻。1975年，刘家良由武指转当导演，开拍《神打》。90年代与成龙合作，推出《醉拳2》等。</p>
<p>刘家良坚持李小龙之后的正宗国术真实武打的路子，他的作品被公认为是真正懂得中国武术且影片深具传统武德精神及家族观念的导演。2010年，刘家良获得了金像奖终身成就奖。</p>
<p>看过老人家的《醉拳Ⅱ》，《七剑》;惜哉，前辈先贤辉煌的那个年代，，还没来得及出生😄，所以无缘得见大师们的顶峰荣光。</p>
<p><img src="http://pic.baike.soso.com/p/20130527/20130527145242-240380703.jpg" alt="刘家良"></p>
<h2 id="功夫老将梁小龙">功夫老将<strong>梁小龙</strong></h2><p>年轻人应该看过他主演的《陈真后转》；周星驰《功夫》中的火云邪神。同李连杰搭档的《不二神探》，真乃老当益壮啊。</p>
<p><a href="http://ww2.sinaimg.cn/mw600/e0f6b799jw1exp7bs6h10j20c63stx3t.jpg" target="_blank" rel="external">梁小龙</a>早在20世纪70年代就在香港演艺圈和李小龙、成龙、狄龙并称为香港演艺圈“四小龙”。祖籍广东的梁小龙生于香港一个贫寒的家庭，15岁时进入武行，并开始做替身演员。</p>
<p>从1973年主演电影《生龙活虎》开始，短短十几年，就拍了《白鹤拳》、《迷魂拳》等70多部电影，后来他进军电视界又连续拍了《射雕英雄传》、《神雕侠侣》、《雪山飞狐》、《霍元甲》、《陈真》、《四大名捕》等1000多集电视剧，成为八十年代初香港最负盛名的武打明星之一。</p>
<p>他先是跟祖父学了三招两式，后来又随戏班里担任武打教师的叔叔学习咏春拳。几年来，叔叔为他打下了坚实的武术根底。后来，他正式拜日本空手道的一位掌门山口刚玄为师，学习搏击整整十年。之后，他又学习了泰国拳和朝鲜拳。</p>
<p>当记者问他：“你的武功属于哪个门派”时，梁小龙笑着说：“在香港和海外，也经常有人向我提出同样的问题，小时候听叔叔讲，他教我的拳脚属于北少林派，非常注重腿功。一个“马步”我就整整练了三年。自从向山口刚玄老师学习搏击以来，吸收了中外百家之长，融会贯通，达到很高的实战功力。</p>
<p>强劲有力的侧踢，跑动中飞身踢腿这些招牌动作使广大影迷记住了梁小龙，虽然他曾经淡出影坛多年，但是他始终没有被人所遗忘!虽然他的很多成绩属于过去，但是鉴于他对功夫电影的贡献和对武术的发扬，“功夫巨星”受之无愧!</p>
<p><img src="http://img.mingxing.com/upload/thumb/2014/05/0-IdavV5.jpg" alt="梁小龙"></p>
<h2 id="十年一剑张晋">十年一剑<strong>张晋</strong></h2><p>那些年看《萧十一郎》，里面有个“雪鹰”，只因诠释出的角色过坏(额，演绎的不错)，记忆犹新；后来看过了《一代宗师》、《杀破狼2》才知道那人叫<strong><a href="http://baike.baidu.com/link?url=NDXU5BfxStGMgPdFiKHcZFrq77ohWkMwZQXNPy2MoBPo228zAKm658xiD7oykIUi7m9HspsfMef7YZQmVArwFtDOPzM89S6buZpxRu6kyCC" target="_blank" rel="external">张晋</a></strong>。</p>
<p>张晋，中国内地男演员，国家武英级武术运动员，1974年5月19日出生于重庆。他9岁习武，11岁进入四川少年武术队，先后取得全国武术比赛陈式太极拳和太极剑冠军，枪术、剑术冠军，八卦掌、醉剑、对练亚军，在第七、八届全国运动会上获得金牌和银牌。</p>
<p>1998年自武术队退役后加入袁和平的“袁家班”从事武术指导。2000年以后逐渐从幕后走向台前，凭借《萧十一郎》、《水月洞天》、《澳门风云》、《一代宗师》、《杀破狼2》等多部影视作品为人所熟知。期间仍兼顾幕后工作，于2003年赴美国好莱坞担任《霹雳娇娃2》《夜魔侠》等影片的武术指导。2007年在《梁山伯与祝英台》中首次担当动作导演。2014年凭借《一代宗师》中的“马三”一角荣获第33届香港电影金像奖“最佳男配角”。</p>
<p>《一代宗师》里的“念念不忘，必有回响”，正好印证了张晋这些年来走过的崎岖路途。当过没名分、没正面镜头的武打替身，遭受过“吃女人软饭”的白眼，这些经验都内化而成张晋演“马三”时心中的那团火。“马三”的绝技“老猿挂印”，其实还有一个连续技叫“回首岁月”，无论如何，张晋熬出头了，有了《一代宗师》，别人终于不再只记得他是“蔡少芬丈夫”（南方都市报评）。</p>
<p>个人倒对《杀破狼2》中张晋饰演的大反派，喜欢的不能自已。文戏武戏，表演皆很出色。尤其动作极为干脆利落没有废招，且力量十足美感充盈；以一敌二，不落下风；其形大有<strong>翩若惊鸿，宛若游龙</strong>之姿，完美的诠释了“头可断发型不能乱，血可流皮鞋不能不擦油”的最高境界；帅到看的女人看到湿，男人看到跪舔有木有？当然张晋死的也很惨，被自己帅死的，他妹的谁打斗还系领带，太帅会死啊太帅会死，记住了<a href="http://www.zhihu.com/question/31417541/answer/52098065" target="_blank" rel="external">SeeHere</a>；既已入道，其前途不可限量。</p>
<p><img src="http://epaper.hilizi.com/bdcb/20150701/188455.jpg" alt="张晋"></p>
<h2 id="功夫小子释小龙">功夫小子<strong>释小龙</strong></h2><p>释小龙，本名陈小龙，1988年1月6日，生于河南郑州，中国男演员。1990年，两岁时拜少林寺第30代接法传人释永信为师，赐法名：释小龙。在1992年中国郑州国际少林武术节表演中，获得少林通臂拳、罗汉棍两项优秀奖。</p>
<p>想必很多人也会记得他诠释的小<strong>展昭</strong>，和少年的<strong>黄飞鸿</strong>吧。1993年8月，与台湾歌星林志颖合拍了第一部影片《旋风小子》。1994年4月与香港影星吴孟达、郑少秋合拍了《新乌龙院》，在台湾创下了两亿的票房成绩，8月与台湾影星金城武、叶全真在美国拍摄了影片《中国龙》，在中国拍摄了《武尊少林》、《少林雄风》等一系列电视片…太多了，幼时的他的确可爱无敌，诠释的角色更是深得民众喜爱，其火红度，想必也是一时无二；只是，随着年岁的增长，身宽体胖了就，也鲜有好作品，实在是可惜。</p>
<h2 id=""><img src="http://p9.qhimg.com/t010e3e615c1fbd5c55.jpg" alt="释小龙"></h2><p><strong>注解：</strong>另有诸多功夫明星，鉴于篇幅(当然也因不多熟悉，就不赘述)然而，他们的名字定然会长存于这功夫影史；譬如我知道的那些大名鼎鼎：</p>
<hr>
<p>一代武师<strong>林正英</strong><br>剑术大师<strong>于承惠</strong><br>七小福之<strong>元彪</strong><br>七小福之<strong>元华</strong><br>武打老姐<strong>郑佩佩</strong><br>武术好手<strong><a href="http://baike.baidu.com/subview/36323/6295788.htm" target="_blank" rel="external">吴樾</a></strong></p>
<p>大反派<strong>邹兆龙</strong><br>大反派<strong>计春华</strong></p>
<p>亦正亦邪<strong>樊少皇</strong><br>亦正亦邪<strong>钱小豪</strong><br>亦正亦邪<strong>释延能</strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/link?url=xd5XdWi-7MIxqrM_E3AFPNFtovdusxwUh-ub0wtaJEqNa5gJIYIfAtCY9RiL_umuEZ549CTdWt7ShxvA34EZTK" target="_blank" rel="external">梁家仁</a></strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/item/刘家辉/5482824" target="_blank" rel="external">刘家辉</a></strong><br>亦正亦邪<strong><a href="http://baike.baidu.com/view/302262.htm" target="_blank" rel="external">熊欣欣</a></strong></p>
<p>腿法超棒<strong>林国斌</strong><br>脚功超群<strong>卢惠光</strong></p>
<p>实力武胜<strong>于荣光</strong><br>世界拳王<strong>周比利</strong></p>
<hr>
<p>另有一些无太棒功夫底子的演员，却也给影视武侠/武打带来诸多不可磨灭贡献；譬如：<strong>周星驰</strong>，<strong>刘德华</strong>，<strong>谢霆锋</strong>，<strong>张卫健</strong>，<strong>何中华</strong>，<strong>梁朝伟</strong>等等等等，就不一一缀言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>见识浅薄，故此必然难以周全。仅以所晓明星作品和人生为基点，个人喜好为腔调来絮叨。耗一日之功来敲打，权作祭奠和分享逝去的功夫片陪伴的那些青葱岁月。若有不妥处，还请见谅。</p>]]>
    
    </summary>
    
      <category term="Share" scheme="http://jeffjade.github.io/tags/Share/"/>
    
      <category term="Share" scheme="http://jeffjade.github.io/categories/Share/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[类数组借用数组方法]]></title>
    <link href="http://jeffjade.github.io/2015/11/02/2015-11-02-likeArray-borrow-ArrayFun/"/>
    <id>http://jeffjade.github.io/2015/11/02/2015-11-02-likeArray-borrow-ArrayFun/</id>
    <published>2015-11-02T04:00:00.000Z</published>
    <updated>2015-11-02T07:19:11.000Z</updated>
    <content type="html"><![CDATA[<p>于JavaScript如何将对象转化为数组对象，其用法写法已经很常见且完善，比如JQuery中的<code>makeArray</code>函数对此的实现，也是跟大家想的差不多，只是考虑的周全些罢了,<a href="#3">看源码</a>；但对于<code>类数组借用数组方法</code>的写法，对其学习探究过程中大长了些许姿势，觉其倒是一个挺有趣问题。</p>
<a id="more"></a>
<h2 id="何为“类数组”"><strong>何为“类数组”</strong></h2><p>JavaScript中有一些看起来像却又不是数组的对象，唤作: <strong>类数组</strong>。一个类数组对象：</p>
<ul>
<li>具有：指向对象元素的数字(非负整数)索引下标以及length属性告诉我们对象的元素个数</li>
<li>不具有：诸如 push forEach 以及 indexOf 等数组对象具有的方法</li>
</ul>
<p>javascript中常见的类数组有arguments对象,DOM方法或者JQuery方法的返回结果。<br>比如<code>document.getElementsByTagName()</code>。实际上，只要有length属性，且它的属性值为number类型即可。</p>
<p><strong>类数组示例：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>,<span class="string">'2'</span>:<span class="string">'love'</span>,<span class="string">'4'</span>:<span class="string">'jeffjade'</span>,length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(a,<span class="string">'+'</span>);<span class="comment">//'+gg+love++jeffjade'</span></span><br></pre></td></tr></table></figure></p>
<p><strong>非类数组示例：</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> c = &#123;<span class="string">'1'</span>:<span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>没有length属性，所以就不是类数组。</p>
<h2 id="借用数组方法"><strong>借用数组方法</strong></h2><h3 id="法一：用数组什么方法，借助call或者apply即可，比如；"><strong>法一</strong>：用数组什么方法，借助call或者apply即可，比如；</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">Array</span>.prototype.push.call(<span class="built_in">arguments</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span> <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">// false</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//OutPut: [1,2,3,4]  //Chrome Console</span></span><br><span class="line">    <span class="comment">//OutPut: / &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125; //SublimeText NodeJs</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<h3 id="法二：函数反柯里化(function_uncurrying)"><strong>法二：</strong>函数反柯里化(function uncurrying)</h3><p><code>Array.prototype</code>上的方法原本只能用来操作array对象。但用<code>call</code> <code>apply</code> 可以把任意对象当做this传入某个方法，如此一来，方法中用到的this的地方就不再局限于原来规定的对象，而是加以泛华并且得到更广的适用性。</p>
<p>但是直接使用这样使用，多少是有些繁琐的。如需使用Array的shift方法，就还得写Like This：<code>Array.prototype.shift.call(arguments);</code>;如能将泛化this的过程提取出来，岂不方便很多？并且代码还能复用。</p>
<p><strong>uncurrying</strong>的话题来自JavaScript之父Brendan Eich在2011年发表的一篇Twitter。<br>以下代码是uncurrying的实现方式之一<strong>@<a href="#1">注解^</a></strong>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> self.apply(obj, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其作用如是：在类数组对象借用<code>Array.prototype</code>方法之前，先把Array.prototype.push.call这句代码转换为一个通用的<code>push</code>函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.uncurrying();</span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">	push(<span class="built_in">arguments</span> , <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">	<span class="comment">//OutPut: [1,2,3,4]  //Chrome Console</span></span><br><span class="line">    <span class="comment">//OutPut: / &#123; '0': 1, '1': 2, '2': 3, '3': 4 &#125; //SublimeText NodeJs</span></span><br><span class="line">&#125;)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>通过<code>uncurrying</code>方式，使得Array.prototype.push.call变成了一个通用的push函数，且其函数的作用也不再仅仅局限于只能操作array对象。于使用者而言，也显得更加简洁和意图明了。</p>
<p>幸甚，还可以一次性地将Array.prototype上的方法“复制”到array对象上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ary = [<span class="string">'push'</span>, <span class="string">'shift'</span>, <span class="string">'forEach'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, fn ; fn = ary[i++];) &#123;</span><br><span class="line">	<span class="built_in">Array</span>[ fn ] = <span class="built_in">Array</span>.prototype[ fn ].uncurrying();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="string">"length"</span>: <span class="number">2</span>,</span><br><span class="line">	<span class="string">"0"</span>:<span class="number">1</span>,</span><br><span class="line">	<span class="string">"1"</span>:<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.push(obj, <span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.length);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Object &#123;0: 1, 1: 2, 2: 3, length: 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> first = <span class="built_in">Array</span>.shift(obj);</span><br><span class="line"><span class="built_in">console</span>.log(first);  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(obj);    <span class="comment">//Object &#123;0: 2, 1: 3, length: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.forEach(obj , <span class="function"><span class="keyword">function</span><span class="params">(i , n)</span></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);  <span class="comment">// 分别输出 2 3</span></span><br><span class="line">	<span class="built_in">console</span>.log(n);  <span class="comment">// 分别输出 0 1</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>当然，<code>function uncurrying</code>还有其他实现方式<strong>@<a href="#2">注解^</a></strong>，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// var obj = Array.prototype.shift.call(arguments);</span></span><br><span class="line">        <span class="comment">// return self.apply(obj, arguments);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="代码稍做分析"><strong>代码稍做分析</strong></h4><p>就取Array.prototype.push.uncurrying()这句代码来分析下，<code>uncurrying</code>的时候发生了什么：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>; <span class="comment">// self此时是Array.prototype.push</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// var obj = Array.prototype.shift.call(arguments); </span></span><br><span class="line">        <span class="comment">// return self.apply(obj, arguments);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>); <span class="comment">//法2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> push = <span class="built_in">Array</span>.prototype.push.uncurrying();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">"length"</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="string">"0"</span>:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">push(obj , <span class="number">2</span>); <span class="comment">//uncurrying函数接收到的arguments即'obj ,2'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">//Outpt: &#123;0:1, 1:2,length:2&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="1">function uncurrying 法一：</h4>

<p>用法一，因为<code>Array.prototype.shift</code>的截断，arguments,即剩下[2]了；相当于如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Array</span>.prototype.shift.call(<span class="built_in">arguments</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Array</span>.prototype.push.apply(obj, <span class="built_in">arguments</span>);<span class="comment">//此时arguments=2；</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2">function uncurrying 法二：</h4>

<p>实现方式二，很有趣;可参见@<a href="http://stackoverflow.com/questions/13004342/call-and-apply-in-javascript" target="_blank" rel="external">stackoverflow透彻回答</a>；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.apply(self, <span class="built_in">arguments</span>);</span><br><span class="line"><span class="comment">//self此时是Array.prototype.push</span></span><br></pre></td></tr></table></figure></p>
<p>大体如此：<code>Function.prototype.call</code>是一个函数；<code>call</code>的this指向<code>Function.prototype</code>;使用<code>apply</code>改变了this的指向到<code>Array.prototype.push</code>;<code>arguments</code> 就被给传了call。原文如下：</p>
<blockquote>
<ol>
<li><code>Function.prototype.call</code> is a function.</li>
<li>The <code>this</code> pointer of <code>call</code> points to <code>Function.prototype</code>.</li>
<li>We use <code>apply</code> to change the <code>this</code> pointer of <code>call</code> to <code>Array.prototype.push</code>.</li>
<li><code>arguments</code> is applied (not passed as a parameter) to call.<blockquote>
<p>The advantage of this is that we’re creating a <strong><a href="http://stackoverflow.com/questions/7459769/whats-the-purpose-of-using-function-call-apply-in-javascript" target="_blank" rel="external">fast unbound wrapper</a></strong> for <code>push</code> in a single line.</p>
</blockquote>
</li>
</ol>
</blockquote>
<p>继续看该Answer，其文提到了<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="external">bind</a>;而<code>bind</code>~绑定函数，会以创建它是传入bind()方法的第一个参数作为<code>this</code>，传入bind()方法的第二个及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。</p>
<p>按照bind的功能，其实在这里bind就可以替代apply， 从而可以有这种写法了咯;而这个bind”听起来”怎么那么像<code>call</code>呢？后面那个方法不过就是改变下前面<code>call</code>的this的指向，所以<code>apply</code>替换<code>call</code>也没什么不可以的嘛，测试一下：果然可以！<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.uncurrying = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return Function.prototype.call.apply(self, arguments); </span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Function</span>.prototype.call.bind(self, <span class="built_in">arguments</span>);</span><br><span class="line">        <span class="comment">// return Function.prototype.call.call(self, arguments);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只是，这样用的话就得为考虑浏览器的兼容性而写些Shim了.如原回答所述：</p>
<blockquote>
<p>A better way to create fast unbound wrappers is as follows (note that it may not work in some older browsers, but you don’t really need to worry about that now - you may always use a <strong><em>shim</em></strong> for browsers which don’t support <strong>bind</strong>):</p>
</blockquote>
<hr>
<p>@JQuery的v2.1.4版本对makeArray方法实现源码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// results is for internal usage only</span></span><br><span class="line">	makeArray: <span class="function"><span class="keyword">function</span><span class="params">( arr, results )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> ret = results || [];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( arr != <span class="literal">null</span> ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( isArraylike( <span class="built_in">Object</span>(arr) ) ) &#123;</span><br><span class="line">				jQuery.merge( ret,</span><br><span class="line">					<span class="keyword">typeof</span> arr === <span class="string">"string"</span> ?</span><br><span class="line">					[ arr ] : arr</span><br><span class="line">				);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				push.call( ret, arr );</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	merge: <span class="function"><span class="keyword">function</span><span class="params">( first, second )</span> </span>&#123;</span><br><span class="line">		<span class="keyword">var</span> len = +second.length,</span><br><span class="line">			j = <span class="number">0</span>,</span><br><span class="line">			i = first.length;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> ( ; j &lt; len; j++ ) &#123;</span><br><span class="line">			first[ i++ ] = second[ j ];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		first.length = i;</span><br><span class="line">		<span class="keyword">return</span> first;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>isArraylike()</code>代码实现可以参见<a href="http://www.jeffjade.com/2015/09/06/2015-09-06-ios8-safari-jitbug-record/" target="_blank" rel="external">这里</a>。</p>
<p><strong>参考出处</strong>：@曾探 所著的《JavaScript设计模式与开发实践》第三章~高阶函数.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>于JavaScript如何将对象转化为数组对象，其用法写法已经很常见且完善，比如JQuery中的<code>makeArray</code>函数对此的实现，也是跟大家想的差不多，只是考虑的周全些罢了,<a href="#3">看源码</a>；但对于<code>类数组借用数组方法</code>的写法，对其学习探究过程中大长了些许姿势，觉其倒是一个挺有趣问题。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[博客引入漂亮字体二三事]]></title>
    <link href="http://jeffjade.github.io/2015/10/28/2015-10-28-css3-webfont/"/>
    <id>http://jeffjade.github.io/2015/10/28/2015-10-28-css3-webfont/</id>
    <published>2015-10-28T13:00:00.000Z</published>
    <updated>2015-11-16T09:37:36.000Z</updated>
    <content type="html"><![CDATA[<p>最近兴致上来，就想更换了那Blog标题字体(汉字的)；网上搜索了一番，发现<code>蘇新詩柳繁體</code>这款甚合我心；然后就着手搞将了起来，分分钟也算是替换了；但，这仅仅是此次折腾的开始；这就细细道来作为学习笔记记载。</p>
<p><img src="http://www.jeffjade.com/img/toss/blogTitleStyle.png" alt=""></p>
<a id="more"></a>
<h2 id="CSS3_@font-face"><strong>CSS3 @font-face</strong></h2><p>当然要使用自定义字体，就得借助下@font-face：CSS3中的一个模块，他主要是把自己定义的Web字体嵌入到你的网页中；@font-face的语法规则如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;</span><br><span class="line">     <span class="rule"><span class="attribute">font-family</span>:<span class="value"> &lt;YourWebFontName&gt;</span></span>;</span><br><span class="line">     <span class="rule"><span class="attribute">src</span>:<span class="value"> &lt;source&gt; [&lt;format&gt;][,&lt;source&gt; [&lt;format&gt;]]*</span></span>;</span><br><span class="line">     <span class="rule">[<span class="attribute">font-weight</span>:<span class="value"> &lt;weight&gt;]</span></span>;</span><br><span class="line">     <span class="rule">[<span class="attribute">font-style</span>:<span class="value"> &lt;style&gt;]</span></span>;</span><br><span class="line">   <span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p><strong>其取值说明：</strong></p>
<ol>
<li><p>YourWebFontName:此值指的就是你自定义的字体名称，最好是使用你下载的默认字体，他将被引用到你的Web元素中的font-family。如“font-family:”YourWebFontName”;”</p>
</li>
<li><p>source:此值指的是你自定义的字体的存放路径，可以是相对路径也可以是绝路径；</p>
</li>
<li><p>format：此值指的是你自定义的字体的格式，主要用来帮助浏览器识别，其值主要有以下几种类型：truetype,opentype,truetype-aat,embedded-opentype,avg等；</p>
</li>
<li><p>weight和style:这两个值大家一定很熟悉，weight定义字体是否为粗体，style主要定义字体样式，如斜体。</p>
</li>
</ol>
<p>在@font-face网络字体技术之前，浏览器显示网页上文字使用的字体只能限制在电脑里已经安装的几款字体里。而且每个人的电脑里安装的字体是因人而异的。@font-face的作用是从网上下载并使用自定义字体，使页面显示字体不依赖用户的操作系统字体环境。</p>
<p>好吧，这里涉及到一个字体format的问题，因为不同的浏览器对字体格式支持是不一致的。使用CSS3自定义字体的时候，为了兼容所有浏览器，服务器需要输出4种格式的字体，分别是eot、svg、ttf和woff。所以，若要尽量更全的支持不同浏览器，那么这里就得这样搞了：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">font-family</span>:<span class="value"> ‘MyFontFamily’</span></span>;</span><br><span class="line">    <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(‘myfont-webfont.eot?#iefix’) <span class="function">format</span>(‘embedded-opentype’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.woff’) <span class="function">format</span>(‘woff’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.ttf’)  <span class="function">format</span>(‘truetype’),</span><br><span class="line">         <span class="function">url</span>(‘myfont-webfont.svg#svgFontName’) <span class="function">format</span>(‘svg’)</span></span>;</span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用@font-face只是申明&amp;定义了一种字体；使用时还是得根据<em>font-family</em>特性加入些默认字体以留后路。即便如此，之后也会有些问题。W3C中描述如下：</p>
<blockquote>
<p><strong>font-family</strong>： <strong>规定元素的字体系列</strong>。可以把多个字体名称作为一个“回退”系统来保存。如果浏览器不支持第一个字体，则会尝试下一个。也就是说，font-family 属性的值是用于某个元素的字体族名称或/及类族名称的一个优先表。浏览器会使用它可识别的第一个值。<br><strong>注意</strong>：使用某种特定的字体系列（Geneva）完全取决于用户机器上该字体系列是否可用；这个属性没有指示任何字体下载。因此，强烈推荐使用一个通用字体系列名作为后路。</p>
</blockquote>
<h2 id="网络字体(Web_font)文件格式"><strong>网络字体(Web font)文件格式</strong></h2><p><strong>WOFF</strong>：Web Open Font Format<br>这种字体格式专门用于网上，由Mozilla联合其它几大组织共同开发。WOFF字体通常比其它字体加载的要快些，因为使用了OpenType (OTF)和TrueType (TTF)字体里的存储结构和压缩算法。这种字体格式还可以加入元信息和授权信息。这种字体格式有君临天下的趋势，因为所有的现代浏览器都开始支持这种字体格式。</p>
<p>支持这种字体的浏览器有【IE9+,Firefox3.5+,Chrome6+,Safari3.6+,Opera11.1+】；</p>
<p><strong>SVG / SVGZ</strong>：Scalable Vector Graphics (Font).<br>SVG是一种用矢量图格式改进的字体格式，体积上比矢量图更小，适合在手机设备上使用。只有iPhone上的Safari(4.1)之前的版本支持它。目前火狐、IE都不支持SVG字体格式。火狐推迟对SVG字体的支持，重点放在WOFF格式上。SVGZ是压缩版的SVG。</p>
<p>支持这种字体的浏览器有【Chrome4+,Safari3.1+,Opera10.0+,iOS Mobile Safari3.2+】。</p>
<p><strong>OTF / TTF</strong>：OpenType Font 和 TrueTypeFont。<br>.ttf字体是Windows和Mac的最常见的字体，是一种RAW格式，因此他不为网站优化。部分的因为这种格式容易被复制(非法的)，这才催生了WOFF字体格式。然而，OpenType有很多独特的地方，受到很多设计者的喜爱。</p>
<p>【IE9+,Firefox3.5+,Chrome4+,Safari3+,Opera10+,iOS Mobile Safari4.2+】；</p>
<p><strong>EOT</strong>：Embedded Open Type。<br>这是微软创造的字体格式(是微软在15年前发明了网络字体@font-face)。这种格式只在IE6/IE8里使用。</p>
<p>.woff字体是Web字体中最佳格式，他是一个开放的TrueType/OpenType的压缩版本。即：最起码要支持下这种格式吧。而网上下载的只有.ttf;所以就开始了字体格式转换。</p>
<h2 id="获取@font-face所需字体格式"><strong>获取@font-face所需字体格式</strong></h2><p>这个阶段折腾的老久了。毕竟是汉字的，网络上搜索的一些在线工具尝试了不少，很好工作的却也不多。<br>最后在这个网站<a href="https://onlinefontconverter.com/" target="_blank" rel="external">https://onlinefontconverter.com/</a>,得到了.woff 和 .svg格式的转换。<a href="http://www.jucelin.cn/archiver/view.asp?id=153" target="_blank" rel="external">Here</a>有介绍。</p>
<p>这里插说一段，在即将放弃的时候，发现了这个网站<a href="http://www.fontsquirrel.com/tools/webfont-generator" target="_blank" rel="external">http://www.fontsquirrel.com/tools/webfont-generator</a>;国外的人士，做事就是认真，一键上传我的.tff格式的字体，它就可以帮助生成对应的4种格式外加.woff2;并且给出CSS以及对应的Demo实例(使用的是 <strong>OPTIMAL</strong>模式)。而且文件还相当的小（5种格式字体加起来就有不到150KB）。惊喜之余，不太相信，一经测试，果然，将汉字给过滤掉了。使<strong>用BASIC模式</strong>确实可以不破坏内容的生成各种格式字体，但难免的，也很大(.woff格式3528KB)。不过，对于英文的转换，还是相当可取的。如何使用?可<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">ClickHere</a>查看。</p>
<p>搞到此处，于大部分浏览器，渲染出<code>蘇新詩柳繁體</code>的标题，是没问题了。即便在Chrome浏览器上一开始是字体未显示，到被默认字体替代了，加载完毕后才重新以<code>蘇新詩柳繁體</code>渲染出来；而Safari则是，从不显示直到加载完毕才渲染出来。手机上能够渲染出来需要的时间就更长了(Android由空白到请求完成后渲染)。(<em>@ο@</em>) 哇～，如此体验着实好*啊。<br>导致这种现象，必然是各大浏览器渲染时存在的差异所致；@w3ctech<a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a>一文中有过详尽的叙述：</p>
<blockquote>
<p>A. 如果请求字体还不可用，IE 会立即使用后备字体呈现，并在字体下载完成之后马上重新呈现；<br>B. Firefox 和 Chrome 35+ 会首先下载3秒钟的字体，如果超过3秒钟后，会使用后备字体渲染网页，等到指定字体下载完成后再重新渲染网页；<br>C. Safari 和 Chrome 35之前的版本，会等到指定字体下载完成后再渲染网页（PS：就是不会使用后备字体）。</p>
<blockquote>
<p><strong>注：</strong>以上说明中没有表示IE的版本以及Safari的版本号，所以需要自己测试才能算正确。<br>因此，如果网络连接缓慢，在大多数浏览器中将延迟超过3秒的文本渲染。在最坏的情况下，如果你的字体加载带有时间限制（由于一些连接很慢的移动设备），Safari 用户将不会再展示文本，剩下一个空白网页。如果网页请求超时，最终将只会呈现一个空白网页。</p>
</blockquote>
</blockquote>
<p>毕竟用的是较全汉字繁体： .ttf格式5735KB;.woff格式3534KB,.svg格式竟然11622KB,有点醉了，555。根据@张鑫旭这篇<a href="http://www.zhangxinxu.com/wordpress/2011/11/fontforge%e8%87%aa%e5%ae%9a%e4%b9%89%e6%89%8b%e6%9c%ba%e5%ad%97%e4%bd%93/" target="_blank" rel="external">fontforge制作自定义字体及在手机上应用举例</a>文中提到的，可以采取软件(Eg:fontforge)提取出自己想要的部分,从而减小字体文件的大小，来增强体验；但是我这边是汉字，折腾起来不容易啊，555。如此，就牵扯到了：网络字体(Web font)的效率问题了。</p>
<h2 id="网络字体(Web_font)的效率"><strong>网络字体(Web font)的效率</strong></h2><p>字体文件的体积可能非常的大(尤其是对于汉字)，而且需要额外的HTTP连接，这些都会降低网站页面的加载速度。所以，在使用网络字体@font-face前，根据网络上的说法：需要清楚它的利与弊，判断网络字体是否真的有必要用在你的网站页面上。</p>
<blockquote>
<p>如果你决定使用个性化自定义字体，可以采用一个非常灵活的方法，就是只加载尽量少的字体字符数和尽量少的字体风格(粗体/斜体)。例如，如果你使用谷歌字体，你可以只加载指定的字体风格组合：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">import</span> <span class="function">url</span>(http://fonts.googleapis.com/css?family=Averia+Sans+Libre:<span class="number">400</span>,<span class="number">300</span>italic,<span class="number">700</span>)</span>;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p>以下是@<a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">Airen的博客</a>对于使用@font-face的写于提醒：</p>
<blockquote>
<ol>
<li>如果你的项目中是英文网站，而且项目中的Logo，Tags等应用到较多的这种特殊字体效果，我建议你不要使用图片效果，而使用@font-face，但是你是中文网站，我觉得还是使用图片比较合适，因为加载英文字体和图片没有多大区别，但是你加载中文字体，那就不一样了，因为中文字体太大了，这样会影响到项目的某些性能的优化；</li>
<li>致命的错误，你在@font-face中定义时，文件路径没有载对；</li>
<li>你只定义了@font-face，但并没有应用到你的项目中的DOM元素上；</li>
</ol>
</blockquote>
<p>就目前我的需求而言，Blog用到这字体，仅是在于标题那5个汉字而已。如不能优化至流畅之境，倒不如采用加载经过Ps处理的图片呢;毕竟之于体验和炫酷间抉择，还是前者更为重要些。然，还是得为此探究一番，万一已经好的解决办法了呢？一查，果真有!喜不自胜。</p>
<h2 id="base64编码字体，自定义你的网站字体！"><strong>base64编码字体，自定义你的网站字体！</strong></h2><p>CSS3给我们带来了@font-face,网页中可以展现的字体就不局限于电脑中已安装的几款字体。@font-face的作用是从网上下载并使用自定义字体，使页面显示字体不依赖用户的操作系统字体环境。</p>
<p>然而：字体文件的体积一般都比较大，而且需要额外的http请求连接，而且需要兼容多种浏览器的话，往往需要三四个或者更多格式的字体文件。尤其是汉字字体文件；于是乎就有了，WebFont (Web Open Font Format)这个技术，极大滴有针对性的压缩了字体文件的体积，压缩了体积就解决了个大问题，很实用。WebFont的字体转换成base64编码，直接放在样式表里面，哇哦，完美。要实现这个，首先我们得<strong>生成下载需要的字体</strong>;毕竟，整个汉字库辣(那)么大，即便生成base64，其体积也不小哇。</p>
<h3 id="生成下载需要的字体"><strong>生成下载需要的字体</strong></h3><p>先设置我们要使用的文字，使用WebFont，推荐阿里妈妈WebFont平台<a href="http://www.iconfont.cn/webfont/#!/webfont/index" target="_blank" rel="external">http://www.iconfont.cn/webfont/#!/webfont/index</a>和有字库<a href="http://www.youziku.com/" target="_blank" rel="external">http://www.youziku.com/</a>，使用简单粗暴，输入你要的文字，下载就完了，代码都给你生成好了。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="at_rule">@<span class="keyword">font-face</span></span> <span class="rules">&#123;<span class="rule"><span class="attribute">font-family</span>:<span class="value"> <span class="string">'webfont'</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.eot'</span>)</span></span>; <span class="comment">/* IE9*/</span></span><br><span class="line">  <span class="rule"><span class="attribute">src</span>:<span class="value"> <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.eot?#iefix'</span>) <span class="function">format</span>(<span class="string">'embedded-opentype'</span>), <span class="comment">/* IE6-IE8 */</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.woff'</span>) <span class="function">format</span>(<span class="string">'woff'</span>), <span class="comment">/* chrome、firefox */</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.ttf'</span>) <span class="function">format</span>(<span class="string">'truetype'</span>), <span class="comment">/* chrome、firefox、opera、Safari, Android, iOS 4.2+*/</span></span><br><span class="line">  <span class="function">url</span>(<span class="string">'//at.alicdn.com/t/glgkzeyrgbonu3di.svg#NotoSansHans-Black'</span>) <span class="function">format</span>(<span class="string">'svg'</span>)</span></span>; <span class="comment">/* iOS 4.1- */</span></span><br><span class="line"><span class="rule">&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>ctrl+c ctrl+v 就解决了需求，在需要的地方使用即可（这里可以直接使用它给你生成的在线字体woff格式等文件【只有你输入的那些汉字喔】），兼容至BT的IE6，简直碉堡。但，好吧，世间没有那么完美的事儿喔。<code>阿里妈妈webfont</code>平台只有思源系的5种不同字体而已，哭晕，没有我倾爱的<code>蘇新詩柳</code>啊。</p>
<h3 id="base64编码字体"><strong>base64编码字体</strong></h3><p>经过譬如上面操作，得到字体文件之后，即可运用一些软件（譬如<a href="http://www.giftofspeed.com/base64-encoder/" target="_blank" rel="external">http://www.giftofspeed.com/base64-encoder/</a>编码之，使之生成base64编码string。<strong>使用：</strong>把处理好了的base64编码放在下面代码中(直接替代xxxxx即可)，然后调用<code>webfont-base</code>这个定义好的字体，大功告成！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@font-face &#123;</span><br><span class="line">    font-family: 'webfont-base';</span><br><span class="line">    src: url(data:font/truetype;charset=utf-8;base64,XXXXXXXXXXXXXXXXX) format('truetype');</span><br><span class="line">    font-weight: normal;</span><br><span class="line">    font-style: normal</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额，好吧，使用这个网站生成的base64也是奇葩的－－有很多空格换行，base64文件蛮大的话，就需要想点办法予以处理下才好。</p>
<p></p><p data-height="268" data-theme-id="20035" data-slug-hash="MaQOOM" data-default-tab="result" data-user="jeffjade" class="codepen">See the Pen <a href="http://codepen.io/jeffjade/pen/MaQOOM/" target="_blank" rel="external">MaQOOM</a> by jeffjade (<a href="http://codepen.io/jeffjade" target="_blank" rel="external">@jeffjade</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><p></p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>

<h3 id="字体文件加载优化"><strong>字体文件加载优化</strong></h3><p>之前已经探明，可以使用字体base64编码信息的CSS字体文件，来替代请求woff格式字体下载；但该CSS文件的大小取决于你选择的字符集合以及相关方面，也许该文件相当的大（最高可达100~300KB）。因此，使用gzip压缩以及设置强缓存的方式对于用户来说是很重要的。</p>
<p>不过幸运的是只有当你网页的浏览者第一次访问该CSS文件的时候会发出请求。由于在第一次的时候，用户本地没有该字体文件，所以浏览器就会去异步加载他们，并且存储在localStorage中。当用户的网络环境较慢的情况下，能够看到后备字体以及webfonts渲染过程，不过这些只会发生在用户第一次访问你网页的时候。大多数用户不会太在意这一细节。</p>
<p>当用户第二次网页页面的时候，浏览器将从localStorage中加载CSS文件内容，这种方式相当的快速（5~50ms）。在这种情况下用户看不到任何的闪烁，因为所有的操作将是同步进行的，这仅仅只需要几毫秒的时间。具体可参见@<a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a>一文所书。</p>
<p><strong>体验至上，优化不止，且学且究，渐探渐优。</strong></p>
<hr>
<p>写在最后，纵使有阿里妈妈这样的平台，但其所针对的汉字字体也太有限。最后还是以图片形式呈现出<code>蘇新詩柳</code>字体的标题(这里采用艺术字体在线转换<a href="http://www.qt86.com/" target="_blank" rel="external">Qt86</a>生成，可惜这个生成的仅是图片，若能成就base64编码，就太棒了。不过它所提供的字体三百余种，可谓丰富)；此处待之后有合适的法子，再继续折腾(Update: 15-11-16)。</p>
<hr>
<p>参考文章链接：<br><a href="http://www.webhek.com/font-face" target="_blank" rel="external">@font-face的用法</a><br><a href="http://guoshuang.com/css/font-face-type/" target="_blank" rel="external">Font-face 字体文件格式</a><br><a href="http://www.w3cplus.com/content/css3-font-face" target="_blank" rel="external">CSS3 @font-face</a><br><a href="http://www.lccky.com/166.html" target="_blank" rel="external">base64编码字体，自定义你的网站字体！</a><br><a href="http://www.w3ctech.com/topic/693" target="_blank" rel="external">在响应式网站中，提升加载webfonts的性能</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近兴致上来，就想更换了那Blog标题字体(汉字的)；网上搜索了一番，发现<code>蘇新詩柳繁體</code>这款甚合我心；然后就着手搞将了起来，分分钟也算是替换了；但，这仅仅是此次折腾的开始；这就细细道来作为学习笔记记载。</p>
<p><img src="http://www.jeffjade.com/img/toss/blogTitleStyle.png" alt=""></p>]]>
    
    </summary>
    
      <category term="CSS" scheme="http://jeffjade.github.io/tags/CSS/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Windows下效率必备软件]]></title>
    <link href="http://jeffjade.github.io/2015/10/19/2015-10-18-Efficacious-win-software/"/>
    <id>http://jeffjade.github.io/2015/10/19/2015-10-18-Efficacious-win-software/</id>
    <published>2015-10-19T10:00:00.000Z</published>
    <updated>2015-11-02T07:06:22.000Z</updated>
    <content type="html"><![CDATA[<p>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！重而说三。</p>
<a id="more"></a>
<p><strong>AutoHotKey</strong>: 神器！神器！神器！当然也得看使用者咯(<em>^__^</em>) 嘻嘻……</p>
<p><strong>Listary</strong>： 本地搜索<strong>神器</strong>，当然还有别的作用，More&amp;More。</p>
<p><strong>Launchy</strong> : 快速启动安装的应用程序，老而弥坚，有丝Mac下Spotlight之风；</p>
<p><strong>Chrome</strong>: Web世界里的神，的神，神。偏爱ing；</p>
<p><strong>SublimeText3</strong>： 编码垒字的神器，还能览图/文件对比/…,偏爱ing；</p>
<p><strong>Picasa3</strong>: 图片查看器中的佼佼者，偏爱ing。姑姑出品，必属精品！</p>
<p><strong>Clover</strong>： 在Win下必备，谁让Win资源管理器太…QT，TotalCommand太重(⊙o⊙)…</p>
<p><strong>Everything</strong>： 本来必备神器，无奈我移情别恋了—Listary。不过是不会忘了你。</p>
<p><strong>Foxmail</strong>： 对比体验不多，不做评判，必备；反正不用win自带的。</p>
<p><strong>Evernote</strong>: 纪录/收藏你想保存的文｜图｜网页;<strong>为知笔记</strong>～功能同丰满,身材更骨感😄。</p>
<p><strong>Beyond Compare</strong> : 文件比较器; 此款为所接触中最佳。</p>
<p><strong><a href="https://github.com/cmderdev/cmder/releases" title="CmderDownAdress" target="_blank" rel="external">Cmder</a></strong>:  windows下cmd的替换工具,支持PowerShell;同比还有PowerShell，<a href="https://github.com/Maximus5/ConEmu" title="ConEmuDownAdress" target="_blank" rel="external">ConEmu</a> 等。</p>
<p><strong><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">作业部落客户端</a></strong>:开启卓越写作之旅,支持全平台＋离线使用，一键发布文稿，社交化批注。身材苗条，面容姣好，免费Markdown书写平台的魅力战斗机。 </p>
<p><strong>夜神模拟器</strong>: 经历了<code>BlueStacks</code>,<code>海马</code>，一遇这<code>夜神</code>,认你乃最佳！</p>
<p><strong>网易云音乐</strong>: 初遇<code>QQ音乐</code>,处过<code>天天动听</code>,恋过<code>酷狗</code>，上过<code>酷我</code>，一夜情过<code>千千静听</code>,移情过<code>虾米</code>，和<code>豆瓣FM</code>好过，同<code>百度随心听</code>约过,最后，发现音乐的世界,还得是你～<strong>网易云音乐</strong>。</p>
<p><strong><a href="http://www.jeffjade.com/2015/05/26/2015-05-26-high-efficiency-tools-collecting/" target="_blank" rel="external">更多关于效率工具文章</a></strong></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！<br>工欲善其事，必先利其器！重而说三。</p>]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vimium~让您的Chrome起飞]]></title>
    <link href="http://jeffjade.github.io/2015/10/19/2015-10-18-chrome-vimium/"/>
    <id>http://jeffjade.github.io/2015/10/19/2015-10-18-chrome-vimium/</id>
    <published>2015-10-19T03:00:00.000Z</published>
    <updated>2015-10-19T10:26:55.000Z</updated>
    <content type="html"><![CDATA[<p><strong>工欲善其事，必先利其器！</strong>撸起Vimium,我的Chrome就这么起飞了。</p>
<a id="more"></a>
<p>如今PC和Mac端安装的Chrome插件(偏前端)：<br><strong>Vimium</strong>：黑客级别的Chrome插件，此文主记载的<strong>主角~(The Hacker’s Browser )</strong>；<br><strong>ABP</strong>： 有她在，WEB的世界就可以清静点了.<br><strong>infinity</strong>：没有最好，只有更好，此款新标签页，如今最爱。<br><strong>crxMouse</strong>: 如果用鼠标操作Chrome,必备=充分发掘鼠标的所有操作。<br><strong>JASN-handle</strong>：Json解析，所用之中综合体验最优者；<br><strong>OK记</strong>： 一键记录你想记载的，体验一流！<br><strong>Pocket</strong>: 轻松保存文章，视频等供以后查看。<br><strong>QR码生成器</strong>： PC阅读-URL转移手机的桥梁，用的不多。<br><strong>WEB前端助手</strong>： 功能虽不少，用的却也少。<br><strong>Website Ip Option</strong>：获取了每个网页Ip显示于屏幕下方。<br><strong>Web Design Tester</strong>：Installed,web Devolop，暂时用的不多。<br><strong>Web Developer</strong>：Installed,web Devolop，暂时用的不多。<br><strong>CssViewer</strong>：Installed,web Devolop，暂时用的不多。<br><strong>PerfectPixel</strong>+<strong>EmmetLiveStyle</strong>: 更便捷精准还原设计图于网页设计，利弊兼有，偶尔用。</p>
<p>更多插件请参见知乎<a href="http://www.zhihu.com/question/19594682" target="_blank" rel="external">你极力推荐的Chrome 扩展有哪些？</a>问题的各种回复。</p>
<hr>
<p>学起(了解几个快捷键即可)And撸起<strong>Vimium</strong>,想黑客一般在Chrome上飞起。<br><strong>Vimium常用快捷键</strong>(注：区分大小写)<br><strong>j</strong>, <c-e> : 向下移动 Scroll down<br><strong>k</strong>, <c-y> : 向上移动Scroll upi<br><strong>h</strong> : 左移 Scroll left<br><strong>l</strong> : 右移 Scroll right</c-y></c-e></p>
<p><strong>H</strong>：回到上一个历史页面<br><strong>L</strong>：回到下一个历史页面<br><strong>J</strong>：跳到左边标签页<br><strong>K</strong>：跳到右边标签页<br><strong>t</strong>：创建新的标签页（ctrl+t）</p>
<p><strong>d</strong> : 向下移动一个页面 Scroll a page down<br><strong>u</strong> : 向上移动一个页面 Scroll a page up</p>
<p><strong>gg</strong> : 移到页面顶部 Scroll to the top of the page<br><strong>G</strong> : 移到页面底部 Scroll to the bottom of the page</p>
<p><strong>x</strong>：关闭当前标签页<br><strong>X</strong>：恢复关闭的标签页</p>
<p><strong>r</strong> : 刷新 Reload the page<br><strong>gs</strong> : 查看网页源码 View page source<br><strong>yy</strong> : copy当前页面url Copy the current URL to the clipboard<br><strong>yf</strong> : 拷贝当前页面的连接到剪切板 Copy a link URL to the clipboard<br><strong>yt</strong> : 创建当前页面的一个副本(copy当前路径在新Tab中打开)-Duplicate current tab<br><strong>YT</strong> : 罗列出当前所有Tab页(并提供索引)，可任你选择性跳转，帅；</p>
<p><strong>p</strong> : 在当前标签页中打开剪切板中的链接 Open the clipboard’s URL in the current tab<br><strong>P</strong> : 在新的标签页中打开剪切板中的链接Open the clipboard’s URL in a new tab</p>
<p><strong>gu</strong> : Go up the URL hierarchy（例如，URL为<a href="http://blog.net/article/8021689" target="_blank" rel="external">http://blog.net/article/8021689</a> ，按下gu后，转到<a href="http://blog.net/article/，回到该网站该访问者主页）" target="_blank" rel="external">http://blog.net/article/，回到该网站该访问者主页）</a><br><strong>gU</strong> : Go to root of current URL hierarchy (类似gu，回到根URL页 <a href="http://blog.net" target="_blank" rel="external">http://blog.net</a>)</p>
<hr>
<p><strong>f</strong> : 在当前标签页中打开链接 Open a link in the current tab<br><strong>F</strong> : 在新标签页中打开链接 Open a link in a new tab</p>
<p>YES: (几乎)所有的操作都是通过键盘的快捷键来操作。如果想点击页面上的某个连接时，在命令模式下，按 f 键之后就会对页面上所有可点击的连接或按钮进行编码，然后再<strong>输入相应的编码完成点击</strong>或者复制连接操作，包含常见的a标签，button标签，input标签中type=button/submit/reset，不过有些也无法识别（flash); 见证如下图：。<br><img src="http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/viumclik.png" alt="Vimium-F-Link"></p>
<hr>
<p><strong>o</strong> : 在当前页面中打开URL，书签和历史记录 Open URL, bookmark, or history entry<br><strong>O</strong> : 在新标签页中打开URL，书签和历史记录Open URL, bookmark, history entry, in a new tab<br><strong>T</strong> : 搜索打开的标签页 Search through your open tabs</p>
<p><strong>b</strong> : 打开书签 Open a bookmark<br><strong>B</strong> : 在新标签中打开书签 Open a bookmark in a new tab<br>在命令行模式，按下b(B)，可以对标签进行检索，检索结果通过tab键进行选择，回车即可打开标签。</p>
<p><img src="http://linxg-wordpress.stor.sinaapp.com/uploads/2014/04/vimbookmap.png" alt="Vimium-bB"></p>
<p>/：查找（ctrl+f）<br><strong>i</strong> : 进入输入模式 Enter insert mode<br><strong>esc</strong>：退出</p>
<hr>
<p>还有些还不怎么常用的，比如：<br><strong>zH</strong> : Scroll all the way to the left<br><strong>zL</strong> : Scroll all the way to the right<br><strong>m</strong> : Create a new mark</p>
<p>最后，任何时候你需要帮助的时候可以按？(shilft+/)来调出帮助菜单，同时显示了所有快捷键的说明,again(shilft+/)即可Close之，如下图：<br><img src="http://images.cnitblog.com/blog/431064/201403/141813348554340.png" alt="vimium-help"></p>
<p>切记(to myself)：<strong>熟能生巧，至巧了，即可夺天之工</strong>。</p>
<p>未完待续…</p>
<p>参考文章链接：<br><a href="http://lin.xiaogang.me/?p=315" target="_blank" rel="external">chrome的vim模式</a><br><a href="http://blog.csdn.net/xiajian2010/article/details/23931273" target="_blank" rel="external">关于vim化浏览器</a></p>
<p>推荐阅读(对于有待更熟悉Win下快捷操作的同志)：<br><a href="http://www.cnblogs.com/wayou/p/shortcuts.html" target="_blank" rel="external">没有鼠标的日子多亏了我精湛的手操，各种快捷键分享</a><br><a href="http://www.jianshu.com/p/3cb5c6f2421c" target="_blank" rel="external">如何优雅地使用Sublime Text3</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p><strong>工欲善其事，必先利其器！</strong>撸起Vimium,我的Chrome就这么起飞了。</p>]]>
    
    </summary>
    
      <category term="Chrome" scheme="http://jeffjade.github.io/tags/Chrome/"/>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/tags/Toss/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精美动画后宫苑]]></title>
    <link href="http://jeffjade.github.io/2015/10/15/2015-10-15-nice-animation-collection/"/>
    <id>http://jeffjade.github.io/2015/10/15/2015-10-15-nice-animation-collection/</id>
    <published>2015-10-15T03:50:00.000Z</published>
    <updated>2015-10-15T10:16:25.000Z</updated>
    <content type="html"><![CDATA[<p>对于觉得美的事物，向来都怀有收藏之癖。迷恋精美网页动画已久，只是未能遇见娇藏她的“铜雀台”。直到一见钟情于她~<code>CodePen</code>站点地址：<a href="http://codepen.io/" target="_blank" rel="external">http://codepen.io/</a>。一款高效在线IDE，不仅站点是在墙内的，并且可免费使用其常用功能；并且功能体验俱佳，真是深得我心啊。至于关于CodePen可以参见：<a href="http://stoneydream.com/2015/09/19/%E4%BD%BF%E7%94%A8codepen%E5%88%86%E4%BA%AB%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81/" target="_blank" rel="external">使用codepen分享前端代码</a>和张鑫旭的<a href="http://www.zhangxinxu.com/wordpress/2012/07/codepen-jsfiddle/" target="_blank" rel="external">见多识广,CodePen项目网站简介</a>。当然，仅仅收藏之，倒无什么意义，待得空闲，须当一一深析以为己用方是正道。</p>
<a id="more"></a>
<p data-height="268" data-theme-id="0" data-slug-hash="YXQoQE" data-default-tab="result" data-user="nikrowell" class="codepen">See the Pen <a href="http://codepen.io/nikrowell/pen/YXQoQE/" target="_blank" rel="external">Scripted Heart</a> by Nik (<a href="http://codepen.io/nikrowell" target="_blank" rel="external">@nikrowell</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p><br><p><script async src="http://codepen.io/assets/embed/ei.js"></script><span id="more-2017"></span></p>

<hr>
<p data-height="268" data-theme-id="20035" data-slug-hash="yYzyWQ" data-default-tab="result" data-user="natewiley" class="codepen">See the Pen <a href="http://codepen.io/natewiley/pen/yYzyWQ/" target="_blank" rel="external">Infinite Cubes CSS</a> by Nate Wiley (<a href="http://codepen.io/natewiley" target="_blank" rel="external">@natewiley</a>) on <a href="http://codepen.io" target="_blank" rel="external">CodePen</a>.</p>]]></content>
    <summary type="html">
    <![CDATA[<p>对于觉得美的事物，向来都怀有收藏之癖。迷恋精美网页动画已久，只是未能遇见娇藏她的“铜雀台”。直到一见钟情于她~<code>CodePen</code>站点地址：<a href="http://codepen.io/">http://codepen.io/</a>。一款高效在线IDE，不仅站点是在墙内的，并且可免费使用其常用功能；并且功能体验俱佳，真是深得我心啊。至于关于CodePen可以参见：<a href="http://stoneydream.com/2015/09/19/%E4%BD%BF%E7%94%A8codepen%E5%88%86%E4%BA%AB%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81/">使用codepen分享前端代码</a>和张鑫旭的<a href="http://www.zhangxinxu.com/wordpress/2012/07/codepen-jsfiddle/">见多识广,CodePen项目网站简介</a>。当然，仅仅收藏之，倒无什么意义，待得空闲，须当一一深析以为己用方是正道。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Cleaver快速制作网页PPT]]></title>
    <link href="http://jeffjade.github.io/2015/10/15/2015-10-16-cleaver-make-ppt/"/>
    <id>http://jeffjade.github.io/2015/10/15/2015-10-16-cleaver-make-ppt/</id>
    <published>2015-10-15T03:50:00.000Z</published>
    <updated>2015-11-17T12:34:30.000Z</updated>
    <content type="html"><![CDATA[<p>如今互联网时代，以浏览器作为入口，已经有越来越多的桌面应用被web应用所取代。微软最赚钱的Office办公软件，也正在被免费的web应用所吞噬。如今即便薄学如我就已然知晓<code>reveal.js</code> <code>impress.js</code>等各种轮子来制作体验优良的网页PPT。今天就来尝试下这Node.js的轮子<code>Cleaver</code>来制作网页PPT。</p>
<p>Cleaver基于HTML5，用最短的时间做出超炫幻灯片。你还会坚持PowerPoint吗？</p>
<a id="more"></a>
<h3 id="Cleaver介绍"><strong>Cleaver介绍</strong></h3><p>如果你已经有了一个Markdown的文档，30秒就可以制作成幻灯片。Cleaver是为Hacker准备的工具。<br>Cleaver的官方发布页：<a href="http://jdan.github.io/cleaver/" target="_blank" rel="external">http://jdan.github.io/cleaver/</a>；<br>参考文章:<a href="http://blog.fens.me/nodejs-slide-cleaver/" target="_blank" rel="external">30秒制作幻灯片 Cleaver</a>。</p>
<h3 id="Cleaver安装"><strong>Cleaver安装</strong></h3><p>系统环境(据悉：支持Linux 和 Mac; cleaver不支持win系统)<br>Linux: Ubuntu 12.04 LTS 64bit<br>node: v0.6.12<br>npm: 1.1.4<br>通过nodejs安装Cleaver<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#23616;&#37096;&#23433;&#35013;Cleaver&#10;~ mkdir nodejs-cleaver &#38;&#38; cd nodejs-cleaver&#10;~ sudo npm install cleaver&#10;&#10;//&#20840;&#23616;&#23433;&#35013;Cleaver&#10;~ sudo npm install cleaver -g</span><br></pre></td></tr></table></figure></p>
<h3 id="Cleaver基本使用"><strong>Cleaver基本使用</strong></h3><p>执行cleaver命令，解析一个markdown文件，会自动生成HTMl文档，欧耶,算是Pandoc的部分功能深入了;</p>
<p>用cleaver自带的例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//&#22914;&#26159;&#23616;&#37096;&#23433;&#35013;&#65292;&#36816;&#34892;&#19979;&#38754;&#19968;&#21477;&#23601;&#22909;&#10;cleaver node_modules/cleaver/examples/basic.md&#10;&#10;//&#22914;&#26159;&#20840;&#23616;&#23433;&#35013;&#65292;&#35831;&#36305;&#36215;Like this&#65306;&#10;cleaver  /usr/local/lib/node_modules/cleaver/examples/basic.md</span><br></pre></td></tr></table></figure></p>
<h3 id="Cleaver配置选项option"><strong>Cleaver配置选项option</strong></h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Basic Example  #HTML&#30340;&#26631;&#39064;&#21517;&#10;author:               #&#20316;&#32773;&#20449;&#24687;,&#22312;&#26368;&#21518;&#19968;&#39029;&#26174;&#31034;&#10;  name: Jordan Scales&#10;  twitter: jdan&#10;  url: http://jeffjade.com&#10;output: basic.html</span><br></pre></td></tr></table></figure>
<p>除此之外还有其他额外设置，譬如：</p>
<ul>
<li>theme: 皮肤(theme: jdan/cleaver-retro)</li>
<li>style: css样式表(style: css/main.css)</li>
<li>output: 生成的HTML文件名(output: basic.html)</li>
<li>controls: 控制按钮(controls: true)</li>
<li>progress: 顶部显示进程条(progress: true)</li>
<li>agenda: 生成一个目录页(progress: false)</li>
<li>encoding: 文档的字符编码(encoding: utf-8)</li>
<li>template: 设置每张slide的模板(template: template/slide.mustache)</li>
<li>layout: 设置HTML模板(template: template/layout.mustache)</li>
</ul>
<h3 id="Cleaver的正文内容:"><strong>Cleaver的正文内容:</strong></h3><p>Cleaver仅支持Markdown语法的，通过Markdown构建网页内容，Markdown官方网站：<a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="external">http://daringfireball.net/projects/markdown/</a></p>
<p>需要注意的是，Cleaver以” — “(两个中横线)做为分页的标志，其他语法都遵循Markdown规则。</p>
<p>MS Office PowerPoint 正在被渐行渐远。。。</p>
<h3 id="写在最后"><strong>写在最后</strong></h3><p>相比于之下，<code>impress.js</code>, <code>reveal.js</code>以及Cleaver三者各有特色吧；在唯快不破的理论下，Cleaver自然占据了无与伦比的优势，只是像动画，样式等比于impress是一个短板。并且，在写此文的时候欲以Cleaver来呈现的，不过总是报出下面这样的问题(Mac OS X Yosemite)：</p>
<blockquote>
<p>!! Cannot read property ‘compiled’ of undefined<br>Please report this to <a href="https://github.com/chjj/marked" target="_blank" rel="external">https://github.com/chjj/marked</a>.</p>
</blockquote>
<p>花了些许时间来探究这个问题，只是现在网络上目测关于这个信息不是很多。逐一对比之下，文章的格式没什么问题。在即将放弃的时候，发现原来是标记代码的时候用了<font color="purple">```shell</font>,所造成的问题,去掉shell或者换成别的也就没有问题了。额…。</p>
<p>点击这里查看：<a href="/special/md2pptViaCleaver.html" style="font-size:1em;font-weight:blod">此文的PPT版本(Cleaver)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>如今互联网时代，以浏览器作为入口，已经有越来越多的桌面应用被web应用所取代。微软最赚钱的Office办公软件，也正在被免费的web应用所吞噬。如今即便薄学如我就已然知晓<code>reveal.js</code> <code>impress.js</code>等各种轮子来制作体验优良的网页PPT。今天就来尝试下这Node.js的轮子<code>Cleaver</code>来制作网页PPT。</p>
<p>Cleaver基于HTML5，用最短的时间做出超炫幻灯片。你还会坚持PowerPoint吗？</p>]]>
    
    </summary>
    
      <category term="Efficiency" scheme="http://jeffjade.github.io/tags/Efficiency/"/>
    
      <category term="NodeJs" scheme="http://jeffjade.github.io/tags/NodeJs/"/>
    
      <category term="Toss" scheme="http://jeffjade.github.io/categories/Toss/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript对象length]]></title>
    <link href="http://jeffjade.github.io/2015/10/08/2015-10-08-js-object-length/"/>
    <id>http://jeffjade.github.io/2015/10/08/2015-10-08-js-object-length/</id>
    <published>2015-10-08T09:30:00.000Z</published>
    <updated>2015-10-09T07:10:58.000Z</updated>
    <content type="html"><![CDATA[<p>前几日有在<a href="http://www.jeffjade.com/2015/09/25/2015-09-25-js-array/#" target="_blank" rel="external">Javascript数组操作</a>一文中稍提及了数组的length属性；深入一点探究，就发现JS这length确有许多难为所知的特性。这就边学边探究下这朵奇葩属性;这里边深入边记载。</p>
<a id="more"></a>
<h2 id="可变的数组length属性">可变的数组length属性</h2><p>和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">5</span>; <span class="comment">//将数组的长度减少到5，索引等于或超过5的元素被丢弃</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素已经变为"undefined"</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">10</span>; <span class="comment">//将数组长度恢复为10</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//虽然长度被恢复为10，但第9个元素却无法收回，显示"undefined"</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure>
<p>length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure>
<h2 id="JS对象的length">JS对象的length</h2><p>在JS中来判断一个对象是否为数组，是需要费点周折的。但以是否具有length属性来衡量之，显然是不合理的。length数组不是独有的，JS对象也是可以用的(当然，数组也是对象的一种～数组对象)。譬如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>, <span class="string">'2'</span>:<span class="string">'love'</span>, <span class="string">'4'</span>:<span class="string">'meimei'</span>, length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p><em>JavaScript中有一些看起来像却又不是数组的对象，唤作</em>: <strong>类数组</strong>。一个类数组对象：</p>
<ul>
<li>具有：指向对象元素的数字索引下标以及<code>length</code>属性告诉我们对象的元素个数</li>
<li>不具有：诸如 <code>push</code>  <code>forEach</code> 以及 <code>indexOf</code> 等数组对象具有的方法</li>
</ul>
<p>两个典型的类数组的例子是：DOM方法 <code>document.getElementsByClassName()</code>的返回结果（实际上许多DOM方法的返回值都是类数组）以及特殊变量 arguments [1]。例如你可以通过以下方法确定函数参数的个数：<code>arguments.length</code><br>你也可以获取单个参数值，例如 <code>arguments[0]</code>。<br>如果这些对象想使用数组的方法，就必须要用某种方式“借用”。这里的“借用”可以借助JS的call，apply方法来实现。有时候处理类数组对象的最好方法是将其转化为数组。 这项工作也可以使用通用方法来完成：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">'1'</span>:<span class="string">'gg'</span>,<span class="string">'2'</span>:<span class="string">'love'</span>,<span class="string">'4'</span>:<span class="string">'meimei'</span>,length:<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.join.call(obj , <span class="string">'+'</span>); <span class="comment">//'+gg+love++meimei'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="类数组判断">类数组判断</h3><p>聊起JS对象的length就有必要说下这个<strong>类数组判断</strong>。之前有在<a href="http://www.jeffjade.com/2015/09/06/2015-09-06-ios8-safari-jitbug-record/" target="_blank" rel="external">IOS 8 Safari JIT bug影响jQuery和underscore</a>记录使用Underscore在IOS机器引起的问题。而对于此问题，jQuery，Underscore方面修复的办法就是改变了<em>类数组判断</em>的判断方式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//underscore 1.7.0 _.each部分代码</span></span><br><span class="line"><span class="keyword">var</span> i, length = obj.length;</span><br><span class="line"><span class="keyword">if</span> (length === +length) &#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对比与underscore1.8.3 _.each部分代码(是采用isArrayLike来判断的)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MAX_ARRAY_INDEX = <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> getLength = property(<span class="string">'length'</span>);</span><br><span class="line"><span class="keyword">var</span> isArrayLike = <span class="function"><span class="keyword">function</span><span class="params">(collection)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = getLength(collection);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> length == <span class="string">'number'</span> &amp;&amp; length &gt;= <span class="number">0</span> &amp;&amp; length &lt;= MAX_ARRAY_INDEX;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> property = <span class="function"><span class="keyword">function</span><span class="params">(key)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">(obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">void</span> <span class="number">0</span> : obj[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于数组是有下标的，其下标的范围是”大于等于0并小于2^32-1的整数”，如果数字太大的话你想难为JavaScript是做不到的。因为其会自动将其转化为”字符串”。而underscore1.8.3用的MaxLength是<code>Math.pow(2, 53) - 1</code>（其值:9007199254740992）,不解😄，待探究下～</p>
<p>而《javascript权威指南》上给出的代码用来判断一个对象是否属于“类数组”。其code如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp;                                <span class="comment">// o is not null, undefined, etc.</span></span><br><span class="line">        <span class="keyword">typeof</span> o === <span class="string">'object'</span> &amp;&amp;            <span class="comment">// o is an object</span></span><br><span class="line">        <span class="built_in">isFinite</span>(o.length) &amp;&amp;               <span class="comment">// o.length is a finite number</span></span><br><span class="line">        o.length &gt;= <span class="number">0</span> &amp;&amp;                    <span class="comment">// o.length is non-negative</span></span><br><span class="line">        o.length===<span class="built_in">Math</span>.floor(o.length) &amp;&amp;  <span class="comment">// o.length is an integer</span></span><br><span class="line">        o.length &lt; <span class="number">4294967296</span>)              <span class="comment">// o.length &lt; 2^32</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;                        <span class="comment">// Then o is array-like</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                       <span class="comment">// Otherwise it is not</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组的存储">数组的存储</h2><p>在JavaScript中数组元素存储是稀疏的，这也就意味着数组的下标不会落在一个连续的数字范围由，只有那些真正存储在数组中的元素才能够分配到内存，其余均不会浪费你宝贵的内存空间。比如如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();   <span class="comment">//声明一个空数组 </span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="string">'jeff'</span>;</span><br><span class="line">arr[<span class="number">1000</span>] = <span class="string">'jade'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length); <span class="comment">//1001 嗯。从0到1000</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">999</span>]);   <span class="comment">//undefined 没有定义</span></span><br></pre></td></tr></table></figure></p>
<p>在JavaScript中数组元素本身，可以是各种类型Null，function，string，object对象等都可以。这一点毋庸置疑；但前两日在学习数组<code>reduce</code>方法的时候，竟然被涨了姿势了，代码走起：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">'pear'</span>,<span class="string">'jade'</span>];</span><br><span class="line"><span class="keyword">var</span> arrJade;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev---:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next---:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        prev[next] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); // [object Array]</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(prev));</span><br><span class="line">        arrJade = prev;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;, []);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"reduce With [] as an additional parameter:"</span>,passValue());</span><br><span class="line"><span class="comment">//reduce With [] as an additional parameter: [ apple: 1, orange: 1, pear: 1, jade: 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrJade.length); <span class="comment">// 0</span></span><br><span class="line">arrJade.push(<span class="string">'jade'</span>);    </span><br><span class="line"><span class="built_in">console</span>.log(arrJade);        <span class="comment">// [ 'jade', apple: 1, orange: 1, pear: 1, jade: 1 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrJade.apple);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p>这里可以看出，可以得到一个类Object对象的数组：只是被包裹的是<code>[]</code>,而非<code>{}</code>；且此时该“数组”是有length属性的，只不过length是0而已。这个“数组”，以console.log(Object.prototype.toString.call(arrJade));来判别是数组无疑。但是倘若类同如此这样直接定义一个“数组”，却是断然不可以的，请看如下代码：。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [apple: <span class="number">1</span>, orange: <span class="number">1</span>]; <span class="comment">//这么搞，编译都过不了，语法错误❌</span></span><br><span class="line"><span class="comment">//Uncaught SyntaxError: Unexpected token : ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//but,可以像使用reduce方法一样，可以构造出这样的数组！</span></span><br><span class="line"><span class="keyword">var</span> arrTest = [];</span><br><span class="line">arrTest[<span class="string">"apple"</span>] = <span class="number">1</span>;</span><br><span class="line">arrTest[<span class="string">"orange"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">//[apple: 1, orange: 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.length) <span class="comment">// 0</span></span><br><span class="line">arrTest.push(<span class="string">'pear'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">// ["pear", apple: 1, orange: 1]</span></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.length) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arrTest.apple); <span class="comment">//1   arrTest['apple']当然也可以访问。</span></span><br><span class="line"></span><br><span class="line">arrTest[<span class="string">"pear"</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arrTest);       <span class="comment">//["pear", apple: 1, orange: 1, pear: 1]</span></span><br></pre></td></tr></table></figure></p>
<p>既然这是一个数组，但为何不能直接如此构造，这一点现在还没搞搞明白，呜呜～。而这样：arrTest[“apple”] = 1; 操纵一个数组，无形的将该项元素对象化了，又没用<code>{}</code>将其包裹，致使其“游离”于此数组一级对象一列，数组能够直接访问。但是，又不在length计数范围。length的数组下表是有对应关系的，当然这里也不能使用数组带下标来访问了。</p>
<p>JS数组，对于诸如Number,String之类的类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引（即C中所说的保存了数据的指针）。这些数据时储存在堆中的某块区间中，堆栈并不是独立的，栈中也可以在堆中存放。那么那些直接游离在数组中的Object元素项，存储地是在哪儿呢？额额，还是没搞搞明白，!?(･_･;?。</p>
<p>对于JS，尚有诸多未知，待学待探究，即便是这随便一个属性：length！！！</p>
<p><a href="http://segmentfault.com/a/1190000000415572" target="_blank" rel="external">javascript 类数组</a><br><a href="http://www.html-js.com/article/1619" target="_blank" rel="external">JavaScript 的怪癖 8：“类数组对象”</a><br><a href="http://www.xiaoxiaozi.com/2009/06/29/1020/" target="_blank" rel="external">JavaScript 创建数组的方法和基本操作</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几日有在<a href="http://www.jeffjade.com/2015/09/25/2015-09-25-js-array/#">Javascript数组操作</a>一文中稍提及了数组的length属性；深入一点探究，就发现JS这length确有许多难为所知的特性。这就边学边探究下这朵奇葩属性;这里边深入边记载。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[精妙JS代码段搜集]]></title>
    <link href="http://jeffjade.github.io/2015/10/06/2015-10-06-perfect-js-code/"/>
    <id>http://jeffjade.github.io/2015/10/06/2015-10-06-perfect-js-code/</id>
    <published>2015-10-06T09:00:00.000Z</published>
    <updated>2015-10-06T12:30:20.000Z</updated>
    <content type="html"><![CDATA[<p>现在到处都是JavaScript，倘若花点时间去体察，每次都能知道点新的东西。一旦你入了门，你总能从这里或是那里领悟到很多知识。一旦发现些许有意思的东西，总习惯先收藏起来。待到时技(时间＋技术)成熟，再去感觉他们的源代码，看一看它们是怎么办到的，览一览大牛们的“奇技淫巧”。这里便是关于所遇精妙JS代码的收藏室，愿随时间的渐行渐远，这里收集的日渐丰盈，技术也能“层林尽染”。</p>
<a id="more"></a>
<h2 id="CSS布局调试代码片段"><strong>CSS布局调试代码片段</strong></h2><p>在浏览器控制台运行此段代码(当然也只能在控制台运用)，会给页面里所有的 DOM 元素添加一个 1px 的描边（outline），方便我们在调试 CSS 过程中分析、排查问题。当然这样的工具使用Chrome一些插件也易办到，但直接撸起如此代码，能够领悟到很多知识。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[].forEach.call($$(<span class="string">"*"</span>),<span class="function"><span class="keyword">function</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">    a.style.outline=<span class="string">"1px solid #"</span>+(~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p><img src="http://www.jeffjade.com/img/css/console-css-outline.png" alt=""></p>
<h3 id="代码分析："><strong>代码分析：</strong></h3><p>这段代码是 Github 上的 140 bytes 活动中的代码，简单分析下这段 JS 代码，作者使用了不少技巧：</p>
<p>首先是需要选择页面上的所有元素，这里使用了只能在console调试工具中使用的$$函数，你可以在console中输入$$(‘a’)自己试一下。它会返回当前页面的所有anchor（链接）元素。<code>$$</code>与<code>document.querySelectorAll</code>是等价的，有兴趣可查看<a href="http://ourjs.com/detail/54ab768a5695544119000007" target="_blank" rel="external">$$和$选择器的历史</a>。</p>
<p>其次遍历所有元素，这里用的是<code>[].forEach.call(...)</code>，使用 <code>forEach</code> 替代 for 之类循环能减少不少代码量，而 forEach 是 Array 对象的方法，所以用了个 [] 空数组来代替Array.prototype,更显简洁;得到所有元素的节点列表（NodeList），但是它并没有实现Array的所有接口，因此使用 $$(‘*’).forEach 会返回错误，这里使用<code>call</code>方法来更改forEach内部this环境，当然也可以使用<code>apply</code>。</p>
<p>之后就是让元素有一个漂亮的边框，并拥有不同的颜色了。这行代码使用了CSS的outline属性。在CSS渲染的盒子模型（Box Model）中，<strong>outline并不会改变元素及其布局的位置</strong>。这里较有意思的是：定义不同的颜色的色值：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~(<span class="built_in">Math</span>.random()*(<span class="number">1</span>&lt;&lt;<span class="number">24</span>))).toString(<span class="number">16</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里想构造的其实是一个16进制的颜色值，即000000～ffffff;也就是parseInt(‘0’,16)到parseInt(‘ffffff’,16)之间的一个值；而<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'ffffff'</span>,<span class="number">16</span>) == <span class="number">16777215</span> == (<span class="number">2</span>^<span class="number">24</span>-<span class="number">1</span>) == (<span class="number">1</span>&lt;&lt;<span class="number">24</span> - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>Math.random(),得到的是一个0～1之间的浮点数；(Math.random()*(1&lt;&lt;24)，即得到0～16777215之间的浮点数，而色值是需要整数的，所以就需要将浮点数进行int转换。这里用到了<code>~~</code>,可参见<a href="http://www.jeffjade.com/2015/05/31/2015-05-31-javascript-operational－symbol/" target="_blank" rel="external">理解JS按为非运算符(~/~~ )</a>。当然可以将~~视为parseInt的简写。并且使用按位或 “|”操作符也可以得到相同的结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1.234567890</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">0.000000001</span>;</span><br><span class="line">~~a == <span class="number">0</span>|a == <span class="built_in">parseInt</span>(a, <span class="number">10</span>) == <span class="number">1</span></span><br><span class="line">~~b == <span class="number">0</span>|b == <span class="built_in">parseInt</span>(b, <span class="number">10</span>) == <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p><code>toString(16)</code>使用数字类型的toString方法进行十进制到16进制的转换。至此我们得到了一个 0 到 16777215之间的随机数，然后使用toString(16)转换成16进制，将此值赋予到页面上所有元素节点的outline附加属性上，就有了如图效果，它就是这样工作的。精致巧妙而实用非常，顶一个。</p>
<p>参考文章<a href="http://ourjs.com/detail/54be0a98232227083e000012" target="_blank" rel="external">从一行CSS调试代码中学到的JavaScript知识</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>现在到处都是JavaScript，倘若花点时间去体察，每次都能知道点新的东西。一旦你入了门，你总能从这里或是那里领悟到很多知识。一旦发现些许有意思的东西，总习惯先收藏起来。待到时技(时间＋技术)成熟，再去感觉他们的源代码，看一看它们是怎么办到的，览一览大牛们的“奇技淫巧”。这里便是关于所遇精妙JS代码的收藏室，愿随时间的渐行渐远，这里收集的日渐丰盈，技术也能“层林尽染”。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://jeffjade.github.io/tags/jQuery/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[〔转〕jQuery编程的最佳实践]]></title>
    <link href="http://jeffjade.github.io/2015/10/04/2015-10-03-use-jquery-better/"/>
    <id>http://jeffjade.github.io/2015/10/04/2015-10-03-use-jquery-better/</id>
    <published>2015-10-04T04:00:00.000Z</published>
    <updated>2015-10-06T08:56:56.000Z</updated>
    <content type="html"><![CDATA[<p>前几日看到这篇关于jQuery的文章，至少如今还觉得很好，就忍将不住的转了来；以备之后深加探究。此文出自“刘哇勇的部落格”<a href="http://www.cnblogs.com/Wayou/p/jquery_best_practise.html" target="_blank" rel="external">jQuery编程的最佳实践</a>；原文出自<a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">Coding Standards &amp; Best Practices</a>。另有一篇关于jQuery的不错文章<a href="http://code.tutsplus.com/tutorials/14-helpful-jquery-tricks-notes-and-best-practices--net-14405" target="_blank" rel="external">14 Helpful jQuery Tricks, Notes, and Best Practices</a>，值得一览，译文在此<a href="http://www.iinterest.net/2010/09/27/%E8%BD%AC14%E6%9D%A1%E5%85%B3%E4%BA%8Ejquery%E7%9A%84%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">14条关于jQuery的知识</a>。</p>
<a id="more"></a>
<p>好像是feedly订阅里看到的文章，读完后觉得非常不错，译之备用，多看受益。</p>
<h2 id="加载jQuery"><strong>加载jQuery</strong></h2><ol>
<li><p>坚持使用CDN来加载jQuery，这种别人服务器免费帮你托管文件的便宜干嘛不占呢。<a href="http://www.sitepoint.com/7-reasons-to-use-a-cdn/" target="_blank" rel="external">点击查看</a>使用CDN的好处，<a href="http://lab.abhinayrathore.com/jquery-standards/#jQueryCND" target="_blank" rel="external">点此</a>查看一些主流的jQuery CDN地址。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"><span class="built_in">window</span>.jQuery || <span class="built_in">document</span>.write(<span class="string">'&lt;script src="js/jquery-1.11.0.min.js" type="text/javascript"&gt;&lt;\/script&gt;'</span>)</span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安全起见，最好还是提供一个本地备份以便在无法从远程CDN服务器获取jQuery时网站也能工作，如上面代码所示。<a href="https://css-tricks.com/snippets/jquery/fallback-for-cdn-hosted-jquery/" target="_blank" rel="external">详情见此</a>。</p>
</li>
<li><p>使用<a href="http://www.paulirish.com/2010/the-protocol-relative-url/" target="_blank" rel="external">裸协议</a>的URL（也就是说去掉http:或者https:），如上面代码展示的那样。</p>
</li>
<li><p>如果可能，尽量将你的JavaScript和jQuery代码放到页面底部。详情移步<a href="https://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-6-move-scripts-bottom-7200.html" target="_blank" rel="external">这里</a>，或者查看一个<a href="https://github.com/h5bp/html5-boilerplate/blob/master/src/index.html" target="_blank" rel="external">HTML5页面标准模板</a>。</p>
</li>
<li><p>该使用哪个版本？</p>
</li>
</ol>
<ul>
<li>如果你想兼容IE678请表用2.x的版本</li>
<li>针对极少数不用考虑兼容性的幸运儿，极力推荐使用最新版本的jQuery</li>
<li>当从CDN服务器加载jQuery时，最好把版本写全（比如1.11.0而不是1.11或者直接写个1）</li>
<li>千万莫重复加载.</li>
</ul>
<ol>
<li><p>如果你同时还使用了其他JS框架诸如Prototype, MooTools, Zepto云云，因为他们也使用了$符号，所以你就表再用美刀符号来进行jQuery 编码了，而请用<code>jQuery</code>代替。并且调用<code>$.noConflict()</code>保证不会有冲突出现。</p>
</li>
<li><p>要检测浏览器对一些新特性是否支持，请用<a href="https://modernizr.com" target="_blank" rel="external">Modernizr</a>。插播广告：<a href="http://www.cnblogs.com/Wayou/p/why_jquery_obselete_brower_detecting.html" target="_blank" rel="external">论为毛不检测浏览器</a>。</p>
</li>
</ol>
<h2 id="关于变量"><strong>关于变量</strong></h2><ol>
<li><p>jQuery类型的变量最好加个$前缀。</p>
</li>
<li><p>时常将jQuery选择器返回的内容存进变量以便重用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $products = $(<span class="string">"div.products"</span>); <span class="comment">// 慢</span></span><br><span class="line"><span class="keyword">var</span> $products = $(<span class="string">".products"</span>); <span class="comment">// 快</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用驼峰命名.</p>
</li>
</ol>
<h2 id="关于选择器"><strong>关于选择器</strong></h2><ol>
<li><p>尽量ID选择器。其背后机理其实是调用原生的<code>document.getElementById()</code>，所以速度较其他选择器快。</p>
</li>
<li><p>使用类选择器时表指定元素的类型。不信你看这个<a href="http://jsperf.com/jqeury-selector-test" target="_blank" rel="external">性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $products = $(<span class="string">"div.products"</span>); <span class="comment">// 慢</span></span><br><span class="line"><span class="keyword">var</span> $products = $(<span class="string">".products"</span>); <span class="comment">// 快</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ID父亲容器下面再查找子元素请用.find()方法。这样做快的原因是通过id选择元素不会使用Sizzle引擎。详情看这里 </p>
</li>
<li><p>多级查找中，右边尽量指定得详细点而左边则尽量简单点。了解更多</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 丑陋</span></span><br><span class="line">$(<span class="string">"div.data .gonzalez"</span>);</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line">$(<span class="string">".data td.gonzalez"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>避免冗余。<a href="http://learn.jquery.com/performance/optimize-selectors/" target="_blank" rel="external">详情</a>或者查看<a href="http://jsperf.com/avoid-excessive-specificity" target="_blank" rel="external">性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">".data table.attendees td.gonzalez"</span>);</span><br><span class="line"><span class="comment">// 好的方式：去掉了中间的冗余</span></span><br><span class="line">$(<span class="string">".data td.gonzalez"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定选择的上下文。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 劣质的代码：因为需要遍历整个DOM来找到.class</span></span><br><span class="line">$(<span class="string">'.class'</span>);</span><br><span class="line"><span class="comment">// 高品代码：因为只需在指定容器范围内进行查找</span></span><br><span class="line">$(<span class="string">'.class'</span>, <span class="string">'#class-container'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表使用万能选择器。查看<a href="http://learn.jquery.com/performance/optimize-selectors/" target="_blank" rel="external">具体阐释</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.container &gt; *'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'div.container'</span>).children(); <span class="comment">// 棒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>警惕隐式的万能选择器。省略的情况下其实使用的就是*号通配符。更多信息</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div.someclass :radio'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'div.someclass input:radio'</span>); <span class="comment">// 棒</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ID已经表示唯一了，背后使用的是document.getElementById()，所以表跟其他选择器混搭了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#outer #inner'</span>); <span class="comment">// 脏</span></span><br><span class="line">$(<span class="string">'div#inner'</span>); <span class="comment">// 乱</span></span><br><span class="line">$(<span class="string">'.outer-container #inner'</span>); <span class="comment">// 差</span></span><br><span class="line">$(<span class="string">'#inner'</span>); <span class="comment">// 干净利落，后台只需调用document.getElementById()</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="DOM操作相关"><strong>DOM操作相关</strong></h2><ol>
<li>操作任何元素前先将其从文档卸载，完了再贴回去。<a href="http://learn.jquery.com/performance/detach-elements-before-work-with-them/" target="_blank" rel="external">这事儿还能说细点</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list-container &gt; ul"</span>).detach();</span><br><span class="line"><span class="comment">//...一大堆对$myList的处理</span></span><br><span class="line">$myList.appendTo(<span class="string">"#list-container"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>2.代码里将HTML组织好后再一次性贴到DOM中去。<a href="http://learn.jquery.com/performance/append-outside-loop/" target="_blank" rel="external">具体来说</a>，<a href="http://jsperf.com/jquery-append-vs-string-concat" target="_blank" rel="external">性能比较</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样不好</span></span><br><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    $myList.append(<span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这样好</span></span><br><span class="line"><span class="keyword">var</span> $myList = $(<span class="string">"#list"</span>);</span><br><span class="line"><span class="keyword">var</span> list = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    list += <span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">$myList.html(list);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 但这样更好</span></span><br><span class="line"><span class="keyword">var</span> array = []; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    array[i] = <span class="string">"&lt;li&gt;"</span>+i+<span class="string">"&lt;/li&gt;"</span>; </span><br><span class="line">&#125;</span><br><span class="line">$myList.html(array.join(<span class="string">''</span>));</span><br></pre></td></tr></table></figure></p>
<p>3.不要处理不存在的元素。<a href="http://learn.jquery.com/performance/dont-act-on-absent-elements/" target="_blank" rel="external">详情</a><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无良的做法：jQuery后台要跑完三个函数后才会知道这个元素其实根本不存在</span></span><br><span class="line">$(<span class="string">"#nosuchthing"</span>).slideUp();</span><br><span class="line"><span class="comment">// 应该这样</span></span><br><span class="line"><span class="keyword">var</span> $mySelection = $(<span class="string">"#nosuchthing"</span>);</span><br><span class="line"><span class="keyword">if</span> ($mySelection.length) &#123;</span><br><span class="line">    $mySelection.slideUp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="事件相关"><strong>事件相关</strong></h2><ol>
<li><p>一个页面只写一个文档ready事件的处理程序。这样代码既清晰好调试，又容易跟踪代码的进程。</p>
</li>
<li><p>表用匿名函数来做事件的回调。匿名函数不易调试维护测试和复用。或许你想较真，看看<a href="http://learn.jquery.com/code-organization/beware-anonymous-functions/" target="_blank" rel="external">这里</a>吧</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;...&#125;); <span class="comment">// 表这样</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myLinkClickHandler</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click"</span>, myLinkClickHandler);</span><br></pre></td></tr></table></figure>
</li>
<li><p>处理文档ready事件的回调也表用匿名函数，匿名函数不易调试维护测试和复用:(</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; ... &#125;); <span class="comment">// 糟糕的做法：无法利用此函数也无法为其写测试用例</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 好的做法</span></span><br><span class="line">$(initPage); <span class="comment">// 抑或 $(document).ready(initPage);</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 这里你可以进行程序的初始化了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进一步，最好也将ready事件的处理程序放到外部文件中引入到页面，而页面中内嵌的代码只需调用即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"my-document-ready.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">    <span class="comment">// 初始化一些必要的全局变量</span></span><br><span class="line">    $(<span class="built_in">document</span>).ready(initPage); <span class="comment">// 抑或 $(initPage);</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>千万表写内联到HTML的JS代码，这是调试的梦魇！应该总是用jQuery来绑定事件自带程序，这样也方便随时动态地取消绑定。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a id="myLink" href="#" onclick="myEventHandler();"&gt;my link&lt;/a&gt; &lt;!--不好 --&gt;</span><br><span class="line">$("#myLink").on("click", myEventHandler); // GOOD</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果可能尽量在绑定事件处理程序时使用一个命名空间，这样可以方便地取消绑定而不会影响其他绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>).on(<span class="string">"click.mySpecialClick"</span>, myEventHandler); <span class="comment">// 不错</span></span><br><span class="line"><span class="comment">// 之后，让我们优雅地解除绑定</span></span><br><span class="line">$(<span class="string">"#myLink"</span>).unbind(<span class="string">"click.mySpecialClick"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="异步操作"><strong>异步操作</strong></h2><ol>
<li><p>直接用$.ajax()而表去用.getJson() 或 .get(),因为jQuery内部还是将其转为前者</p>
</li>
<li><p>表对HTTPS站点使用HTTP去发起请求，最好干脆就表指定（将HTTP或者HTTPS从你的URL中移除）</p>
</li>
<li><p>表在链接里面嵌参数，请使用专门的参数设置来传递</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不易阅读的代码...</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"something.php?param1=test1&amp;param2=test2"</span>,</span><br><span class="line">    ....</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 更易阅读...</span></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"something.php"</span>,</span><br><span class="line">    data: &#123; param1: test1, param2: test2 &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量指明数据类型以便你自己清楚要处理什么样的数据（见下方会提到的Ajax模板）</p>
</li>
<li><p>对于异步动态加载的内容，最好使用代理来绑定事件处理程序。这样的好处是对于之后动态加载的元素事件同样有效。你或许想<a href="http://api.jquery.com/on/" target="_blank" rel="external">了解更多</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#parent-container"</span>).on(<span class="string">"click"</span>, <span class="string">"a"</span>, delegatedClickHandlerForAjax);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>6.使用Promise模式。<a href="http://www.htmlgoodies.com/beyond/javascript/making-promises-with-jquery-deferred.html" target="_blank" rel="external">更多例子</a><br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123; <span class="keyword">...</span> &#125;).then(successHandler, failureHandler);</span><br><span class="line"> </span><br><span class="line">// 抑或</span><br><span class="line">var jqxhr = $.ajax(&#123; <span class="keyword">...</span> &#125;);</span><br><span class="line">jqxhr.done(successHandler);</span><br><span class="line">jqxhr.fail(failureHandler);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>标准的Ajax模板一分。<a href="https://api.jquery.com/jQuery.ajax/" target="_blank" rel="external">追寻根源</a><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax(&#123;</span><br><span class="line">    url: url,</span><br><span class="line">    type: <span class="string">"GET"</span>, <span class="comment">// 默认为GET,你可以根据需要更改</span></span><br><span class="line">    cache: <span class="literal">true</span>, <span class="comment">// 默认为true,但对于script,jsonp类型为false,可以自行设置</span></span><br><span class="line">    data: &#123;&#125;, <span class="comment">// 将请求参数放这里.</span></span><br><span class="line">    dataType: <span class="string">"json"</span>, <span class="comment">// 指定想要的数据类型</span></span><br><span class="line">    jsonp: <span class="string">"callback"</span>, <span class="comment">// 指定回调处理JSONP类型的请求</span></span><br><span class="line">    statusCode: &#123; <span class="comment">// 如果你想处理各状态的错误的话</span></span><br><span class="line">        <span class="number">404</span>: handler404,</span><br><span class="line">        <span class="number">500</span>: handler500</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">jqxhr.done(successHandler);</span><br><span class="line">jqxhr.fail(failureHandler);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="动画与特效"><strong>动画与特效</strong></h2><ol>
<li>保持一个始终如一风格统一的动画实现</li>
<li>紧遵用户体验，表滥用动画特效</li>
</ol>
<p>使用简洁的显示隐藏，状态切换，滑入滑出等效果来展示元素<br>使用预设值来设置动画的速度’fast’，’slow’，或者400（中等速度）</p>
<h2 id="插件相关"><strong>插件相关</strong></h2><ol>
<li>始终选择一个有良好支持，完善文档，全面测试过并且社区活跃的插件</li>
<li>注意所用插件与当前使用的jQuery版本是否兼容</li>
<li>一些常用功能应该写成jQuery插件。<a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">一分jQuery插件的编写模板</a></li>
</ol>
<h2 id="链式句法"><strong>链式句法</strong></h2><ol>
<li><p>除了用变量将jQuery选择器返回的结果保存，还可以利用好链式调用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myDiv"</span>).addClass(<span class="string">"error"</span>).show();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当链式调用多达3次以上或代码因绑定回调略显复杂时，使用换行和适当的缩进来提高代码的可读性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myLink"</span>)</span><br><span class="line">    .addClass(<span class="string">"bold"</span>)</span><br><span class="line">    .on(<span class="string">"click"</span>, myClickHandler)</span><br><span class="line">    .on(<span class="string">"mouseover"</span>, myMouseOverHandler)</span><br><span class="line">    .show();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于特别长的调用最好还是用变量保存下中间结果来简化代码。</p>
</li>
</ol>
<h2 id="其他"><strong>其他</strong></h2><ol>
<li><p>使用对象字面量来传递参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$myLink.attr(<span class="string">"href"</span>, <span class="string">"#"</span>).attr(<span class="string">"title"</span>, <span class="string">"my link"</span>).attr(<span class="string">"rel"</span>, <span class="string">"external"</span>); <span class="comment">// 糟糕：调用了三次attr</span></span><br><span class="line"><span class="comment">// 不错，只调用了一次attr</span></span><br><span class="line">$myLink.attr(&#123;</span><br><span class="line">    href: <span class="string">"#"</span>,</span><br><span class="line">    title: <span class="string">"my link"</span>,</span><br><span class="line">    rel: <span class="string">"external"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>表将CSS与jQuery杂揉</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#mydiv"</span>).css(&#123;<span class="string">'color'</span>:red, <span class="string">'font-weight'</span>:<span class="string">'bold'</span>&#125;); <span class="comment">// 不好</span></span><br><span class="line"></span><br><span class="line">.error &#123;<span class="comment">/* 不错 */</span></span><br><span class="line">    color: red;</span><br><span class="line">    font-weight: bold;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#mydiv"</span>).addClass(<span class="string">"error"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>时刻关注官方Changelog，表使用摒弃了的方法。<a href="http://api.jquery.com/category/deprecated/" target="_blank" rel="external">点此</a>查看所有废弃的方法.</p>
</li>
<li><p>适时地使用原生JavaScript。<a href="http://jsperf.com/document-getelementbyid-vs-jquery/3" target="_blank" rel="external">一些与此有关的性能比较</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#myId"</span>); <span class="comment">// 多少还是会逊色于...</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"myId"</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="REFERENCE"><strong>REFERENCE</strong></h2><p>原文：Coding Standards &amp; Best Practices <a href="http://lab.abhinayrathore.com/jquery-standards/" target="_blank" rel="external">http://lab.abhinayrathore.com/jquery-standards/</a></p>
<p>原文的reference<br>jQuery Performance: <a href="http://learn.jquery.com/performance/" target="_blank" rel="external">http://learn.jquery.com/performance/</a><br>jQuery Learn: <a href="http://learn.jquery.com" target="_blank" rel="external">http://learn.jquery.com</a><br>jQuery API Docs: <a href="http://api.jquery.com/" target="_blank" rel="external">http://api.jquery.com/</a><br>jQuery Coding Standards and Best Practice: <a href="http://www.jameswiseman.com/blog/2010/04/20/jquery-standards-and-best-practice/" target="_blank" rel="external">http://www.jameswiseman.com/blog/2010/04/20/jquery-standards-and-best-practice/</a><br>jQuery Plugin Boilerplate: <a href="http://stefangabos.ro/jquery/jquery-plugin-boilerplate-revisited/" target="_blank" rel="external">http://stefangabos.ro/jquery/jquery-plugin-boilerplate-revisited/</a> </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几日看到这篇关于jQuery的文章，至少如今还觉得很好，就忍将不住的转了来；以备之后深加探究。此文出自“刘哇勇的部落格”<a href="http://www.cnblogs.com/Wayou/p/jquery_best_practise.html">jQuery编程的最佳实践</a>；原文出自<a href="http://lab.abhinayrathore.com/jquery-standards/">Coding Standards &amp; Best Practices</a>。另有一篇关于jQuery的不错文章<a href="http://code.tutsplus.com/tutorials/14-helpful-jquery-tricks-notes-and-best-practices--net-14405">14 Helpful jQuery Tricks, Notes, and Best Practices</a>，值得一览，译文在此<a href="http://www.iinterest.net/2010/09/27/%E8%BD%AC14%E6%9D%A1%E5%85%B3%E4%BA%8Ejquery%E7%9A%84%E7%9F%A5%E8%AF%86/">14条关于jQuery的知识</a>。</p>]]>
    
    </summary>
    
      <category term="jQuery" scheme="http://jeffjade.github.io/tags/jQuery/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Javascript数组操作]]></title>
    <link href="http://jeffjade.github.io/2015/09/25/2015-09-25-js-array/"/>
    <id>http://jeffjade.github.io/2015/09/25/2015-09-25-js-array/</id>
    <published>2015-09-25T13:30:00.000Z</published>
    <updated>2015-10-08T13:34:49.000Z</updated>
    <content type="html"><![CDATA[<p>使用JS也算有段时日，然对于数组的使用，总局限于很初级水平，且每每使用总要查下API，或者写个小Demo测试下才算放心，一来二去，浪费不少时间；思虑下，堪能如此继续之？当狠心深学下方是正道。</p>
<a id="more"></a>
<h2 id="一,_数组常用方法">一, <strong>数组常用方法</strong></h2><h3 id="1-_数组的创建">1. <strong>数组的创建</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>();　<span class="comment">//创建一个数组</span></span><br><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([size]);　<span class="comment">//创建一个数组并指定长度，注意不是上限，是长度</span></span><br><span class="line"><span class="keyword">var</span> arrayObj = <span class="keyword">new</span> <span class="built_in">Array</span>([element0[, element1[, ...[, elementN]]]]);　<span class="comment">//创建一个数组并赋值</span></span><br></pre></td></tr></table></figure>
<p>要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变</p>
<h3 id="2-_数组的元素的访问">2. <strong>数组的元素的访问</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testGetArrValue=arrayObj[<span class="number">1</span>]; <span class="comment">//获取数组的元素值</span></span><br><span class="line">arrayObj[<span class="number">1</span>]= <span class="string">"这是新值"</span>; <span class="comment">//给数组元素赋予新的值</span></span><br></pre></td></tr></table></figure>
<h3 id="3-_数组元素的添加">3. <strong>数组元素的添加</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj. push([item1 [item2 [. . . [itemN ]]]]);<span class="comment">// 将一个或多个新元素添加到数组结尾，并返回数组新长度</span></span><br><span class="line">arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);<span class="comment">// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度</span></span><br><span class="line">arrayObj.splice(insertPos,<span class="number">0</span>,[item1[, item2[, . . . [,itemN]]]]);<span class="comment">//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回""。</span></span><br></pre></td></tr></table></figure>
<h3 id="4-_数组元素的删除">4. <strong>数组元素的删除</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.pop(); <span class="comment">//移除最后一个元素并返回该元素值</span></span><br><span class="line">arrayObj.shift(); <span class="comment">//移除最前一个元素并返回该元素值，数组中元素自动前移</span></span><br><span class="line">arrayObj.splice(deletePos,deleteCount); <span class="comment">//删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="5-_数组的截取和合并">5. <strong>数组的截取和合并</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.slice(start, [end]); <span class="comment">//以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素</span></span><br><span class="line">arrayObj.concat([item1[, item2[, . . . [,itemN]]]]); <span class="comment">//将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组</span></span><br></pre></td></tr></table></figure>
<h3 id="6-_数组的拷贝">6. <strong>数组的拷贝</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.slice(<span class="number">0</span>); <span class="comment">//返回数组的拷贝数组，注意是一个新的数组，不是指向</span></span><br><span class="line">arrayObj.concat(); <span class="comment">//返回数组的拷贝数组，注意是一个新的数组，不是指向</span></span><br></pre></td></tr></table></figure>
<h3 id="7-_数组元素的排序">7. <strong>数组元素的排序</strong></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.reverse(); <span class="comment">//反转元素（最前的排到最后、最后的排到最前），返回数组地址</span></span><br><span class="line">arrayObj.sort(); <span class="comment">//对数组元素排序，返回数组地址</span></span><br></pre></td></tr></table></figure>
<h3 id="8-_数组元素的字符串化">8. <strong>数组元素的字符串化</strong></h3><p><code>join()</code>方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arrayObj.join(separator); <span class="comment">//返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></span><br></pre></td></tr></table></figure></p>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
<p><code>valueOf</code>: 与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br><span class="line">arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></span><br><span class="line">arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></span><br></pre></td></tr></table></figure></p>
<p>toLocaleString 、toString：可以看作是join的特殊用法，不常用;<br><strong>toLocaleString()</strong>: 方法可根据本地时间把 Date 对象转换为字符串，并返回结果。</p>
<p><strong>toString</strong>:把数组转换为字符串，并返回结果。</p>
<p><strong>lastIndexOf</strong>：返回在数组中搜索到的与给定参数相等的元素的最后（最大）索引。</p>
<p><strong>toSource()</strong>: 返回一个字符串,代表该数组的源代码.<font color="red">该特性是非标准的，请尽量不要在生产环境中使用它！</font> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/toSource" target="_blank" rel="external">Array.prototype.toSource()</a></p>
<h2 id="二、数组对象的3个属性"><strong>二、数组对象的3个属性</strong></h2><h3 id="1-_length属性">1. <strong>length属性</strong></h3><p>Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，JavaScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];<span class="comment">//定义了一个包含10个数字的数组</span></span><br><span class="line">alert(arr.length); <span class="comment">//显示数组的长度10</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">12</span>; <span class="comment">//增大数组的长度</span></span><br><span class="line">alert(arr.length); <span class="comment">//显示数组的长度已经变为12</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素的值，为56</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">5</span>; <span class="comment">//将数组的长度减少到5，索引等于或超过5的元素被丢弃</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//显示第9个元素已经变为"undefined"</span></span><br><span class="line"></span><br><span class="line">arr.length=<span class="number">10</span>; <span class="comment">//将数组长度恢复为10</span></span><br><span class="line">alert(arr[<span class="number">8</span>]); <span class="comment">//虽然长度被恢复为10，但第9个元素却无法收回，显示"undefined"</span></span><br></pre></td></tr></table></figure></p>
<p>由上面的代码我们可以清楚的看到length属性的性质。但length对象不仅可以显式的设置，它也有可能被隐式修改。JavaScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素索引的值加1。例如下面的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">12</span>,<span class="number">23</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">25</span>,<span class="number">98</span>,<span class="number">76</span>,<span class="number">54</span>,<span class="number">56</span>,<span class="number">76</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">arr[<span class="number">15</span>] = <span class="number">34</span>;</span><br><span class="line"><span class="built_in">console</span>.log(arr.length);  <span class="comment">//16</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]);     <span class="comment">//undefine</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.toString())</span><br><span class="line"><span class="comment">//12,23,5,3,25,98,76,54,56,76,,,,,,34</span></span><br></pre></td></tr></table></figure></p>
<p>代码中同样是先定义了一个包含10个数字的数组，通过alert语句可以看出其长度为10。随后使用了索引为15的元素，将其赋值为15，即 arr[15]=34，这时再用alert语句输出数组的长度，得到的是16。无论如何，对于习惯于强类型编程的开发人员来说，这是一个很令人惊讶的特性。事实上，使用new Array()形式创建的数组，其初始长度就是为0，正是对其中未定义元素的操作，才使数组的长度发生变化。</p>
<p>大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，<strong>不建议直接修改Array的大小，访问索引时要确保索引不会越界。</strong></p>
<p>由上面的介绍可以看到，length属性是如此的神奇，利用它可以方便的增加或者减少数组的容量。因此对length属性的深入了解，有助于在开发过程中灵活运用。</p>
<h3 id="2-_prototype_属性">2. <strong>prototype 属性</strong></h3><p>返回对象类型原型的引用。prototype 属性是 object 共有的。</p>
<p><strong>objectName.prototype</strong>:objectName 参数是object对象的名称。<br>说明：用 prototype 属性提供对象的类的一组基本功能。 对象的新实例“继承”赋予该对象原型的操作。<br>对于数组对象，以以下例子说明prototype 属性的用途。</p>
<p>给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">array_max</span><span class="params">()</span></span><br><span class="line"> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i,</span><br><span class="line">    max = <span class="keyword">this</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="keyword">this</span>.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; <span class="keyword">this</span>[i])</span><br><span class="line">        max = <span class="keyword">this</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Array</span>.prototype.max = array_max;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line"><span class="keyword">var</span> y = x.max();</span><br></pre></td></tr></table></figure></p>
<p>该代码执行后，y 保存数组 x 中的最大值，即：6。</p>
<h3 id="3-_constructor_属性">3. <strong>constructor 属性</strong></h3><p>表示创建对象的函数。object.constructor //object是对象或函数的名称。</p>
<p>说明：constructor 属性是所有具有 prototype 的对象的成员。它们包括除 Global 和 Math 对象以外的所有 JScript 固有对象。constructor 属性保存了对构造特定对象实例的函数的引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"Hi"</span>);</span><br><span class="line"><span class="keyword">if</span> (x.constructor == <span class="built_in">String</span>) <span class="comment">// 进行处理（条件为真）。</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunc</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 函数体。</span></span><br><span class="line">&#125;</span><br><span class="line">y = <span class="keyword">new</span> MyFunc;</span><br><span class="line"><span class="keyword">if</span> (y.constructor == MyFunc) <span class="comment">// 进行处理（条件为真）。</span></span><br><span class="line"></span><br><span class="line">y = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<h2 id="三、判断是否为数组"><strong>三、判断是否为数组</strong></h2><p>js因为设计上的某些缺陷，导致在对于Array的判断，也是颇费周折的。<br><code>typeof 操作符</code>:对于Function， String， Number ，Undefined 等几种类型的对象来说，他完全可以胜任，但是为Array时,难免会让人失望：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);</span><br><span class="line">alert(<span class="keyword">typeof</span>(arr));  <span class="comment">// Object</span></span><br></pre></td></tr></table></figure></p>
<p><code>instanceof 操作符</code>: 运算符会返回一个 Boolean 值，指出对象是否是特定类的一个实例。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayStr=<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);</span><br><span class="line">alert(arrayStr <span class="keyword">instanceof</span> <span class="built_in">Array</span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>虽然此时能够完好的工作，但，事实上在多个frame中穿梭就会产生大问题了。所以~~~<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);    </span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);    </span><br><span class="line">xArray = <span class="built_in">window</span>.frames[<span class="built_in">window</span>.frames.length-<span class="number">1</span>].Array;       </span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> xArray(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>);<span class="comment">//这个写法IE大哥下是不支持的，FF下才有</span></span><br><span class="line">       </span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// false </span></span><br><span class="line">alert(arr.constructor === <span class="built_in">Array</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>ECMA-262中规范定义了Object.prototype.toString的行为：首先，取得对象的一个内部属性[[Class]]，然后依据这个属性，返回一个类似于”[object Array]”的字符串作为结果（看过ECMA标准的应该都知道，[[]]用来表示语言内部用到的、外部不可直接访问的属性，称为“内部属性”）。利用这个方法，再配合call，我们可以取得任何对象的内部属性[[Class]]，然后把类型检测转化为字符串比较，以达到我们的目的。于是利用这点，就有了下面这种方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span><span class="params">(obj)</span> </span>&#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">'[object Array]'</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>call改变toString的this引用为待检测的对象，返回此对象的字符串表示，然后对比此字符串是否是’[object Array]’，以判断其是否是Array的实例。也许你要问了，为什么不直接o.toString()？嗯，虽然Array继承自Object，也会有toString方法，但是这个方法有可能会被改写而达不到我们的要求，而Object.prototype则是老虎的屁股，很少有人敢去碰它的，所以能一定程度保证其“纯洁性”：）。这也是Array.isArray()方法的兼容旧环境（Polyfill）。</p>
<p>如此很好的解决了跨frame对象构建的问题，经过测试，各大浏览器兼容性也很好，可以放心使用。很多框架，比如jQuery、Base2等等，都计划借鉴此方法以实现某些特殊的，比如数组、正则表达式等对象的类型判定！当然也可以写成如下这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray2</span> <span class="params">(v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.apply(v) === <span class="string">'[object Array]'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>要注意的是：toString方法极有可能被重写，所以需要使用的时候，可以直接使用Object.prototype.toString()方法。</p>
<p><code>Array.isArray()</code><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="external">^See</a>方法用来判断某个值是否为数组。如果是，则返回 true，否则返回 false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的函数调用都返回 true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]);</span><br><span class="line"><span class="built_in">Array</span>.isArray([<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>());</span><br><span class="line"><span class="comment">// 鲜为人知的事实：其实 Array.prototype 也是一个数组。</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">Array</span>.prototype); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面的函数调用都返回 false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray();</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123;&#125;);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">undefined</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="number">17</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="string">'Array'</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">Array</span>.isArray(&#123; __proto__: <span class="built_in">Array</span>.prototype &#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="四,_数组迭代过程"><strong>四, 数组迭代过程</strong></h2><h3 id="filter()_^See"><strong>filter()</strong> <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter" target="_blank" rel="external">^See</a></h3><p><strong>方法使用指定的函数测试所有元素，并创建一个包含所有通过测试的元素的新数组。</strong><br>语法：arr.filter(callback[, thisArg])<br>如果为 filter 提供一个 thisArg 参数，则它会被作为 callback 被调用时的 this 值。否则，callback 的 this 值在非严格模式下将是全局对象，严格模式下为 undefined。</p>
<blockquote>
<p>filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或 等价于 true 的值 的元素创建一个新数组。callback 只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过 callback 测试的元素会被跳过，不会被包含在新数组中。</p>
</blockquote>
<p><strong>示例</strong>：筛选排除掉所有的小值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> element &gt;= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> filtered = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].filter(isBigEnough);</span><br><span class="line"><span class="comment">// filtered is [12, 130, 44]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="forEach()_^See">forEach() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" target="_blank" rel="external">^See</a></h3><p><strong>方法让数组的每一项都执行一次给定的函数。</strong><br>语法: array.forEach(callback[, thisArg])</p>
<blockquote>
<p>forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者从未赋值的项将被跳过（但不包括哪些值为 undefined 的项）。</p>
</blockquote>
<p><em>forEach 遍历的范围在第一次调用 callback 前就会确定。调用forEach 后添加到数组中的项不会被 callback 访问到。如果已经存在的值被改变，则传递给 callback 的值是 forEach 遍历到他们那一刻的值。已删除的项不会被遍历到。</em> <strong>注意： 没有办法中止 forEach 循环。如果要中止，可使用  Array.every 或 Array.some。见下面的例子。</strong></p>
<p><strong>示例1</strong>:打印出数组的内容<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logArrayElements</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"a["</span> + index + <span class="string">"] = "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">[<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>].forEach(logArrayElements);</span><br><span class="line"><span class="comment">// logs:</span></span><br><span class="line"><span class="comment">// a[0] = 2</span></span><br><span class="line"><span class="comment">// a[1] = 5</span></span><br><span class="line"><span class="comment">// a[2] = 9</span></span><br></pre></td></tr></table></figure></p>
<p><strong>示例2</strong>:一个可以克隆对象的函数<br>使用下面的代码可以复制一个给定的对象,虽然有很多不同的复制对象的方法.不过下面介绍的这种方法使用了Array.prototype.forEach和其他一些ECMAScript 5中的Object.*函数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> copy = <span class="built_in">Object</span>.create( <span class="built_in">Object</span>.getPrototypeOf(o) );</span><br><span class="line">  <span class="keyword">var</span> propNames = <span class="built_in">Object</span>.getOwnPropertyNames(o);</span><br><span class="line"></span><br><span class="line">  propNames.forEach(<span class="function"><span class="keyword">function</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(o, name);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(copy, name, desc);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;a:<span class="number">1</span>, b:<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = copy(o1); <span class="comment">// o2 looks like o1 now</span></span><br></pre></td></tr></table></figure></p>
<h3 id="every()_^See">every() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/every" target="_blank" rel="external">^See</a></h3><p><strong>方法测试数组的所有元素是否都通过了指定函数的测试。</strong><br>语法:arr.every(callback[, thisArg])</p>
<blockquote>
<p>every 方法为数组中的每个元素执行一次 callback 函数，直到它找到一个使 callback 返回 falsy（表示可转换为布尔值 false 的值）的元素。如果发现了一个这样的元素，every 方法将会立即返回 false。否则，callback 为每一个元素返回 true，every 就会返回 true。callback 只会为那些已经被赋值的索引调用。不会为那些被删除或从来没被赋值的索引调用。<strong>callback 被调用时传入三个参数：元素值，元素的索引，原数组。</strong> <em>every 不会改变原数组。</em></p>
</blockquote>
<p>实例：检测所有数组元素的大小<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测数组中的所有元素是否都大于 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">54</span>, <span class="number">18</span>, <span class="number">130</span>, <span class="number">44</span>].every(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="map()_^See">map() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="external">^See</a></h3><p><strong>方法返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组。</strong></p>
<p>语法: array.map(callback[, thisArg])</p>
<blockquote>
<p>map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值组合起来形成一个新数组。 callback 函数只会在有值的索引上被调用；那些从来没被赋过值或者使用 delete 删除的索引则不会被调用。<strong>map 不修改调用它的原数组本身（当然可以在 callback 执行时改变原数组）。</strong></p>
</blockquote>
<p>实例一：求数组中每个元素的平方根<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在一个 String  上使用 map 方法获取字符串中每个字符所对应的 ASCII 码组成的数组：</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Array</span>.prototype.map</span><br><span class="line"><span class="keyword">var</span> a = map.call(<span class="string">"Hello World"</span>, <span class="function"><span class="keyword">function</span><span class="params">(x)</span> </span>&#123; <span class="keyword">return</span> x.charCodeAt(<span class="number">0</span>); &#125;)</span><br><span class="line"><span class="comment">// a的值为[72, 101, 108, 108, 111, 32, 87, 111, 114, 108, 100]</span></span><br></pre></td></tr></table></figure></p>
<p>通常情况下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。但这并不意味着 map 只给 callback 传了一个参数。这个思维惯性可能会让我们犯一个很容易犯的错误。比如下面的语句返回什么呢:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// 你可能觉的会是[1, 2, 3]</span></span><br><span class="line"><span class="comment">// 但实际的结果是 [1, NaN, NaN]</span></span><br></pre></td></tr></table></figure></p>
<p>通常使用parseInt时,只需要传递一个参数.但实际上,parseInt可以有两个参数.第二个参数是进制数.可以通过语句”alert(parseInt.length)===2”来验证. </p>
<p>map方法在调用callback函数时,会给它传递三个参数:当前正在遍历的元素, 元素索引, 原数组本身.<br>第三个参数parseInt会忽视, 但第二个参数不会,也就是说,parseInt把传过来的索引值当成进制数来使用.从而返回了NaN。 因此此时应该使用如下的用户函数returnInt：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnInt</span><span class="params">(element)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">parseInt</span>(element,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>].map(returnInt);</span><br><span class="line"><span class="comment">// 返回[1,2,3]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="some()_^See">some() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/some" target="_blank" rel="external">^See</a></h3><p><strong>方法测试数组中的某些元素是否通过了指定函数的测试。</strong></p>
<p>语法: arr.some(callback[, thisArg])</p>
<blockquote>
<p><strong>描述</strong>:some 为数组中的每一个元素执行一次 callback 函数，直到找到一个使得 callback 返回一个“真值”（即可转换为布尔值 true 的值）。如果找到了这样一个值，some 将会立即返回 true。否则，some 返回 false。callback 只会在那些”有值“的索引上被调用，不会在那些被删除或从来未被赋值的索引上调用。</p>
</blockquote>
<p>示例：测试数组元素的值<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测在数组中是否有元素大于 10。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBigEnough</span><span class="params">(element, index, array)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (element &gt;= <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> passed = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is false</span></span><br><span class="line">passed = [<span class="number">12</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">4</span>].some(isBigEnough);</span><br><span class="line"><span class="comment">// passed is true</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reduce()_^See">reduce() <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">^See</a></h3><p><strong>接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。</strong><br>语法: arr.reduce(callback,[initialValue])<br><strong>callback:</strong>执行数组中每个值的函数，包含四个参数</p>
<ul>
<li>previousValue:上一次调用回调返回的值，或者是提供的初始值（initialValue）</li>
<li>currentValue 数组中当前被处理的元素</li>
<li>index 当前元素在数组中的索引</li>
<li>array 调用 reduce 的数组<br><strong>initialValue:</strong> 作为第一次调用 callback 的第一个参数。</li>
</ul>
<blockquote>
<p><strong>描述</strong>:reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。</p>
<p>回调函数第一次执行时，previousValue 和 currentValue 可以是一个值，如果 initialValue 在调用 reduce 时被提供，那么第一个 previousValue 等于 initialValue ，并且currentValue 等于数组中的第一个值；如果initialValue 未被提供，那么previousValue 等于数组中的第一个值，currentValue等于数组中的第二个值。</p>
<p>如果数组为空并且没有提供initialValue， 会抛出TypeError 。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue， 或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。</p>
</blockquote>
<p>示例1：将数组所有项相加<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> total = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// total == 6</span></span><br></pre></td></tr></table></figure></p>
<p>示例2: 数组扁平化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flattened = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]].reduce(<span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.concat(b);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// flattened is [0, 1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></p>
<p>示例2: 统计一个数组中有多少个不重复的单词</p>
<p>不使用reduce时的写法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWordCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i= <span class="number">0</span>, l = arr.length; i&lt; l; i++)&#123;</span><br><span class="line">        <span class="keyword">var</span> item = arr[i];</span><br><span class="line">        obj[item] = (obj[item] +<span class="number">1</span> ) || <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getWordCnt());</span><br></pre></td></tr></table></figure></p>
<p>使用reduce()后的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">"pear"</span>,<span class="string">"orange"</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getWordCnt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        prev[next] = (prev[next] + <span class="number">1</span>) || <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getWordCnt());</span><br></pre></td></tr></table></figure>
<p>这其中一个需要注意的点在于，initialValue提供与否对prev和next的影响；<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 二者的区别，在console中运行一下即可知晓*/</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">"apple"</span>,<span class="string">"orange"</span>,<span class="string">'pear'</span>,<span class="string">'jade'</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">noPassValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); //prev type:string</span></span><br><span class="line">        <span class="keyword">return</span> prev + <span class="string">" "</span> +next;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev,next)</span></span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"prev:"</span>,prev);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"next:"</span>,next);</span><br><span class="line">        </span><br><span class="line">        prev[next] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//console.info('prev type:'+ typeof(prev)); // object</span></span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;,&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"No Additional parameter:"</span>,noPassValue());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"----------------"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"With &#123;&#125; as an additional parameter:"</span>,passValue());</span><br></pre></td></tr></table></figure></p>
<h2 id="一点总结："><strong>一点总结：</strong></h2><p>pop,push,reverse,shift,sort,splice,unshift  会改变原数组<br>join,concat,indexOf,lastIndexOf,slice,toString 不会改变原数组<br>map,filter,some,every,reduce,forEach这些迭代方法不会改变原数组</p>
<p>几个注意点：</p>
<ol>
<li>shift,pop会返回那个被删除的元素</li>
<li>splice 会返回被删除元素组成的数组，或者为空数组</li>
<li>push 会返回新数组长度</li>
<li>some 在有true的时候停止</li>
<li>every 在有false的时候停止</li>
<li>上述的迭代方法可以在最后追加一个参数thisArg,它是执行 callback 时的 this 值。</li>
</ol>
<p>JavaScript的数据类型分为：值类型和引用类型(地址值)；而常见的引用类型有Object和Array／数组的存储模型中，如果是诸如Number,String之类的类型数据会被直接压入栈中，而引用类型只会压入对该值的一个索引（即C中所说的保存了数据的指针）。这些数据时储存在堆中的某块区间中，堆栈并不是独立的，栈中也可以在堆中存放。在使用Array的进行赋值操作的时候，也当注意是否要进行深度拷贝复制(可借助arr.slice(0))，以免造成对自身污染。对于Js数据，其实内容还是还有很多需要学习的，比如ArrayBuffer等。根据学以致用的原则，这些等到需要的时候再去学吧。</p>
<p>参考文章如下：<br><a href="http://www.cnblogs.com/qiantuwuliang/archive/2011/01/08/1930499.html" target="_blank" rel="external">js数组操作</a><br><a href="http://www.nowamagic.net/librarys/veda/detail/1250" target="_blank" rel="external">js如何判断一个对象是不是Array？</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array#Mutator_.E6.96.B9.E6.B3.95" target="_blank" rel="external">MDN-Array</a><br><a href="http://segmentfault.com/a/1190000002753931?utm_source=tuicool" target="_blank" rel="external">盘点JavaScript里好用的原生API</a><br><a href="http://ourjs.com/detail/54a9f2ba5695544119000005" target="_blank" rel="external">5个现在就该使用的数组Array方法</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>使用JS也算有段时日，然对于数组的使用，总局限于很初级水平，且每每使用总要查下API，或者写个小Demo测试下才算放心，一来二去，浪费不少时间；思虑下，堪能如此继续之？当狠心深学下方是正道。</p>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://jeffjade.github.io/tags/JavaScript/"/>
    
      <category term="Front-End" scheme="http://jeffjade.github.io/categories/Front-End/"/>
    
  </entry>
  
</feed>
